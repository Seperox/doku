\documentclass[10pt,a4paper]{scrartcl}
\pagestyle{empty}
\usepackage{a4wide}
\usepackage[ngerman]{babel} % Neudeutsche Silbentrennung (mehrsprachiges Dokument)
\usepackage{parskip} % Skip indentation of first row
\usepackage{graphicx} % Graphics support
\usepackage{longtable} % Tables across several pages
\usepackage{booktabs}
\usepackage{mdwlist} % lists with less spacing, use itemize*
\usepackage{hyperref} % Hyperlinks
\usepackage{float} % Force float position
\usepackage[automark]{scrpage2} %kopf/fusszeile
\usepackage{listings}
\usepackage[utf8x]{inputenc} % Unicode-Encoding
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{mdframed}
\mdfdefinestyle{def}{%
	linecolor=gray!50!white,
	outerlinewidth=0.5pt,
	roundcorner=3pt,
	skipabove=\topskip,
	skipbelow=\topskip
	innertopmargin=\baselineskip,
	innerbottommargin=\baselineskip,
	innerrightmargin=10pt,
	innerleftmargin=10pt
}

\lstset{
	basicstyle=\linespread{.94}\ttfamily,
	tabsize=2,
}

\linespread{1.3}

\author{Danilo Bargen, Christian Fässler, Jonas Furrer} 
\title{REST API\\strongTNC BA}

\pagestyle{scrheadings}
\ihead{REST API} %linke Kopfzeile
\ohead{strongTNC BA} %rechte Kopfzeile

\let\textquotedbl="

\begin{document}

\begin{titlepage}
	\maketitle
	\vspace{120mm}
	\thispagestyle{empty} % Don't start page numbers on this page
\end{titlepage}

\newpage
	\tableofcontents
\newpage

\section{Einleitung}

Die Definition der Ressourcen orientiert sich an den Regeln des Buches
\textit{REST API Design Rulebook} \cite{masse2011rest} aus dem O'Reilly Verlag.

\subsubsection*{URI Definition}

Bei der Bezeichnung der URIs\footnote{Uniform Resource Identifier} wurde folgende Terminologie gemäss RFC 3986 verwendet:

\texttt{URI = scheme \textquotedbl ://\textquotedbl{} authority \textquotedbl /\textquotedbl{}
path [ \textquotedbl ?\textquotedbl{} query ] [ \textquotedbl \#\textquotedbl{} fragment ]}

\subsubsection*{Ressource-Archetypen}

Nachfolgend die Ressource-Archetypen gemäss \cite{masse2011rest}. Die Erklärungstexte wurden direkt dem besagten
Buch entnommen.

\begin{description}
	\item[Document] A document resource is a singular concept that is akin to an object instance or database
		record. A document’s state representation typically includes both fields with values and
		links to other related resources.
	\item[Collection] A collection resource is a server-managed directory of resources. Clients may propose
		new resources to be added to a collection. However, it is up to the collection to choose
		to create a new resource, or not.
	\item[Store] A store is a client-managed resource repository. A store resource lets an API client put
		resources in, get them back out, and decide when to delete them. On their own, stores
		do not create new resources; therefore a store never generates new URIs. Instead, each
		stored resource has a URI that was chosen by a client when it was initially put into the
		store.
	\item[Controller] A controller resource models a procedural concept. Controller resources are like
		executable functions, with parameters and return values; inputs and outputs.
		Like a traditional web application’s use of HTML forms, a REST API relies on controller
		resources to perform application-specific actions that cannot be logically mapped to
		one of the standard methods (create, retrieve, update, and delete, also known as
		CRUD).
\end{description}

\pagebreak
\section{Repräsentation der Archetypen}

Die JSON-Repräsentation ist abhängig vom Ressource-Archetypen.

\begin{description}
	\item[Document] Ein Document gibt ein JSON Objekt zurück, welches alle relevanten Felder enthält.
		Informationen, welche durch die Ressource-URI bereits gegeben sind (zB type), müssen nicht, können
		jedoch, erneut in der Liste erscheinen.\\
		Falls im Document Unterobjekte auftauchen, wird für das Feld die URI des betreffenden Unterobjekts
		eingesetzt, damit kann dieses Objekt direkt abgefragt werden. Zusätzlich wird ein Query-Parameter
		bereit gestellt, welcher es erlaubt, Unterobjekte bis zu einer gewissen Tiefe aufzulösen.\\
		Beispiel: \hfill
\begin{lstlisting}
{
	"feld1": "<str,wert1>",
	"feld2": <int,wert2>,
	"feld3": <bool,wert3>,
	"unterobjekt": "<uri,unterobjekt>"
	"untercollection": [
		{
			"uri": "<uri,unterobjekt>"
		},
		{
			"uri": "<uri,unterobjekt>"
		}
	]
}
\end{lstlisting}
Beispiel mit Query \texttt{depth=1}:
\begin{lstlisting}
{
	"feld1": "<str,wert1>",
	"feld2": <int,wert2>,
	"feld3": <bool,wert3>,
	"unterobjekt": {
		"feld1": <int,feld1>,
		...
		"uri": "<uri,unterobjekt>"
	}
	"untercollection": [
		{
			"feld": <int, feld>,
			...
			"uri": "<uri,unterobjekt>"
		},
		{
			"feld": <int, feld>,
			...
			"uri": "<uri, unterobjekt>"
		}
	]
}
\end{lstlisting}

	\item[Collection] Eine Collection gibt eine Liste mit allen enthaltenen (ggf. gefilterten)
		JSON-Objekten zurück. Die Objekte werden zusätzlich um ein Feld \texttt{uri} ergänzt,
		welches die Ressource-URI des jeweiligen Objektes enthält. Wie bei einem Document gibt es bei
		Collections einen optionalen Query Parameter welcher es erlaubt Unterobjekte aufzulösen, \\
		Beispiel: \hfill
\begin{lstlisting}
{
	{
		"feld1": "<str,feld1>",
		"unterobjekt": "<uri,unterobjekt>",
		"uri": "<uri,objek>"
	},
	{
		"feld1": "'<str,feld1>",
		"unterobjekt": "<uri,unterobjekt>",
		"uri": "<uri,objekt>"
	},
}
\end{lstlisting}
Beispiel mit Query \texttt{depth=1}:1
\begin{lstlisting}
{
	{
		"feld1": "<str,feld1>",
		"unterobjekt": {
			"feld": "<str,feld>",
		},
		"uri": "<uri,objekt>"
	},
	{
		"feld1": "'<str,feld1>",
		"unterobjekt": {
			"feld": "<str,feld>",
		},
		"uri": "<uri,objekt>"
	},
}
\end{lstlisting}

	\item[Store] Ein Store verhält sich wie eine Collection, wenn sie direkt angesprochen wird
		(\texttt{/store}) und wie ein Document, wenn ein spezifisches Element des Store angesprochen
		wird (\texttt{/store/\{element-id\}}).
	\item[Controller] Der Output des Controllers ist abhängig vom Verwendungszweck.
\end{description}

\pagebreak
\section{HTTP Statuscodes}
Das Ergebnis einer Anfrage wird grundsätzlich über einen HTTP Statuscode mitgeteilt, gewissen Fällen
kann auch noch Payload im Body geliefert werden. Folgendes ist eine Auswahl von Statuscodes die zu
erwarten sind:
\begin{description*}
	\item[201 Created] Entity wurde erfolgreich erstellt
	\item[204 No Content] Entity wurde erfolgreich geändert
	\item[400 Bad Request] Generischer Client Fehler
	\item[404 Not Found] Zu änderndes Entity nicht gefunden
	\item[405 Method Not Allowed] Die verwendete HTTP Methode ist auf dieser Ressource nicht erlaubt
	\item[409 Conflict] Zu erstellendes Entity existiert bereits
	\item[412 Precondition Failed] Es sind zusätzliche Schritte nötig um die Anfrage auszuführen.
	\item[500 Internal Server Error] Generischer Client Fehler
\end{description*}

\pagebreak
\section{Allgemeine Hinweise}

\subsection{Schreibweise}
Für die Definition des Response- und Request-Formats wird eine pseudo JSON schreibweise verwendet. Die
auszufüllenden Werte werden als Tupel in spitzen Klammern dargestellt. Der erste Teil des Tupels zeigt 
den Typ, der zweite Teil steht zur Beschreibung für den Wert. Folgende Typen werden verwendet:
\begin{description*}
    \item[int] Integer Zahlenwert
    \item[num] Dezimalzahl, 
    \item[str] String
    \item[bool] Wahrheitswert
    \item[uri] Die voll qualifizerte URI einer Resource
    \item[doc] Das Dokument einer Resource, wie dieses Aussieht kann im jeweiligen Abschnitt zur genannten Resource nachgeschlagen werden
\end{description*}

\subsection{Standard Verhalten}
Folgende Punkte beschreiben das standard Verhalten der Resourcen:
\begin{description*}
    \item[Depth Query-Parameter] Jede Resource die als Antwort eine URI auf eine andere Resource zurück gibt                         unterstützt den \texttt{depth} Query-Parameter. Dieser löst die URIs bis zur gewünschten tiefe auf. Möglicherweise wird die maximale Tiefe eingeschränkt. Wenn keine tiefe angegeben wird, gilt die Auflösungstiefe 0.
    \item[Filter Query-Parameter] Filter Query-Parameter sind, falls vorhanden, immer optional, sie dienen der Präzisierung des Rückgabesets. Wenn sie weggelassen werden, wird das vollständige Set zurückgegeben.
\end{description*}
 
\subsection{Bisher verwendete SQL Vorgänge}
\paragraph{Session}
\begin{description*}
	\item[SQL] \texttt{SELECT/INSERT/JOIN(devices,results)}
	\item[Felder] *id, *device, *time, connection, product, identity, +rec
\end{description*}

\paragraph{Workitem}
\begin{description*}
	\item[SQL] \texttt{SELECT/INSERT/DELETE/JOIN(enforcements)}
	\item[Felder] *id, *session, *result, enforcement, type, arg\_str, arg\_int, rec\_fail, rec\_noresult, rec\_final
\end{description*} 
 
\paragraph{Products}
\begin{description*}
	\item[SQL] \texttt{SELECT/INSERT}
	\item[Felder] id, *name
\end{description*}

\paragraph{Packages}
\begin{description*}
	\item[SQL] \texttt{SELECT/INSERT}
	\item[Felder] id, *name
\end{description*}

\paragraph{Versions}
\begin{description*}
	\item[SQL] \texttt{SELECT/INSERT/DELETE}
	\item[Felder] *id, *product, *package, release, security, blacklist, time
\end{description*}

\paragraph{Identities}
\begin{description*}
	\item[SQL] \texttt{SELECT/INSERT}
	\item[Felder] id, *type, *value
\end{description*}

\paragraph{Devices}
\begin{description*}
	\item[SQL] \texttt{SELECT/INSERT/JOIN(sessions)}
	\item[Felder] *id, *value, *product, trusted, created, +desription
\end{description*}

\paragraph{Enforcements}
\begin{description*}
	\item[SQL] \texttt{SELECT/JOIN(policies,workitems)}
	\item[Felder] *id, *group\_id, policy, rec\_fail, rec\_noresult, max\_age
\end{description*}

\paragraph{Policies}
\begin{description*}
	\item[SQL] \texttt{SELECT/JOIN(enforcements)}
	\item[Felder] *id, type, argument, rec\_fail, rec\_noresult, file, dir, +name
\end{description*}

\paragraph{Results}
\begin{description*}
	\item[SQL] \texttt{SELECT/INSERT/JOIN(sessions)}
	\item[Felder] *policy, session, rec, result, +id
\end{description*}

\paragraph{Groups}
\begin{description*}
	\item[SQL] \texttt{SELECT}
	\item[Felder] *id, parent, +name
\end{description*}

\paragraph{Groups\_members}
\begin{description*}
	\item[SQL] \texttt{SELECT/INSERT}
	\item[Fe•lder] *device\_id, group\_id, +id
\end{description*}

\paragraph{Groups\_products\_defaults}
\begin{description*}
	\item[SQL] \texttt{SELECT}
	\item[Felder] *product\_id, group\_id, +id
\end{description*} 


\pagebreak
\section{REST Ressourcen}

\subsection{Session Steuerung und Ablauf}

\subsubsection{Controller}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/sessions/create}
	\item[Archetype] Controller
	\item[Methods] POST
	\item[Request Parameter] \hfill
    \begin{description*}
        \item[\texttt{connection-id}] strongSwan Connection Id
        \item[\texttt{device-id}] Device identifikation
        \item[\texttt{TODO}] Welche Informationen werden benötigt
    \end{description*}
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"session-id": <int,id>,
	"uri": "<uri,resource>"
}
\end{lstlisting}
    \item[Beschreibung] Dieser Controller erstellt und startet eine Session. Die Id die im Response Dokument zurück geliefert wird, dient zur zukünftigen Identifikation der soeben gestarteten Session.
\end{description*}
\end{mdframed}


\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/sessions/\{id\}/getWorkitem}
	\item[Archetype] Controller
	\item[Methods] POST
	\item[Request Parameter] \hfill
    \begin{description*}
        \item[\texttt{type}] Typ des gewünschten Workitems. Der Typ steht für den Policy Type.
    \end{description*}
	\item[JSON Format Response] \hfill
\begin{lstlisting}
<doc,workitem>
\end{lstlisting}
    \item[Beschreibung] Der Request auf diesen Controller gibt ein Workitem mit dem gewünschten Typ zurück. Der Controller stellt sicher, dass ein Workitem immer nur einmal zurück gegeben wird.
\end{description*}
\end{mdframed}


\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/sessions/\{id\}/close}
	\item[Archetype] Controller
	\item[Methods] POST
    \item[Beschreibung] Dieser Controller schliesst die Session ab.
\end{description*}
\end{mdframed}

\pagebreak
\subsubsection{Daten}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/sessions/\{id\}}
	\item[Archetype] Readonly Document
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"time": <int,time>,
	"identity": "<uri,identity>",
	"connection-id": <int,connection-id>,
	"device": "<uri,device>",
	"product": "<uri,product>",
	"recommendation": <int,rec>
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/sessions}
	\item[Archetype] Readonly Collection
	\item[Filter Query] \hfill
    \begin{description*}
        \item[time-from] \texttt{<int,timestamp>}
        \item[time-to] \texttt{<int,timestamp>}
    \end{description*}	
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id>,
		"time": <int,time>,
		"identity": "<uri,identity>",
		"connection-id": <int,connection-id>,
		"device": "<uri,device>",
		"product": "<uri,product>",
		"recommendation": <int,rec>
		"uri": "<uri,resource>"
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/session/\{id\}/workitems}
	\item[Archetype] Readonly Collection
	\item[Filter Query] \hfill
	\begin{description*}
	    \item[type] \texttt{<int,policy-type>}
	\end{description*}
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	<doc,workitem>
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/workitems/\{id\}}
	\item[Archetype] Document
	\item[Methods] GET, PATCH
	\item[Request Parameter] \hfill
    \begin{description*}
        \item[\texttt{recommendation}] Empfehlung als folge des Messergebnisses für dieses Workitem.
        \item[\texttt{comment}] Kommentar zur Empfehlung.
    \end{description*}
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"session": "<uri,session>",
	"enforcement": "<uri,enforcement>",
	"type": <int,type>,
	"argument": <doc,workitem-argument>,
	"recommendation": <int,recommendation>,
	"comment": "<str,comment>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/workitems/\{id\}/enforcement}
	\item[Archetype] Readonly Collection
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
<doc,enforcement>
\end{lstlisting}
\end{description*}
\end{mdframed}

\pagebreak
\subsection{Controller für Messungen}

\subsubsection{SWID Tags: Messung}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/session/\{id\}/swidMeasurement}
	\item[Archetype] Controller
	\item[Methods] POST
	\item[Response Statuscodes] \hfill
		\begin{description*}
			\item[200 OK] SWID Tags der übermittelten Software-IDs sind eingetragen \\
			und wurden für die übermittelte Session eingetragen
			\item[412 Precondition Failed] Es existieren nicht alle SWID Tags für die übertragenen Software-IDs.\\
			Als Payload werden die fehlenden Software-IDs übertragen.
		\end{description*}
	\item[Request Parameter] \hfill
    \begin{description*}
        \item[\texttt{software-id}] Eine kommagetrennte Liste von Software Ids
    \end{description*}
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	"<str,software-id>"
]
\end{lstlisting}
    \item[Beschreibung] Die strongSwan Komponente sendet eine Liste von Software-IDs an die strongTNC 
Schnittstelle. Die Software-IDs wurden zuvor auf dem Client gemessen und widerspiegeln die momentan
installierten Software Pakete.\\
Wenn bereits SWID Tags für alle übertragenen Software-IDs bestehen, können diese direkt eingetragen werden.
\end{description*}
\end{mdframed}


\subsubsection{SWID Tags: Erstellung}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/swid/addTags}
	\item[Archetype] Controller
	\item[Methods] POST
	\item[Request Parameter] \hfill
    \begin{description*}
        \item[\texttt{xml-data}] TODO Encoding? 
    \end{description*}
    \item[Beschreibung] Die übermittelten Tags werden gelesen und in die Datenbank gespeichert. Bereits vorhandene Tags werden übersprungen, beziehungsweise ergänzt, wenn der neu übermittelte Tag mehr optionale Felder enthält als der bereits gespeicherte.
\end{description*}
\end{mdframed}

\pagebreak
\subsection{CRUD Resourcen}
\subsubsection{Products}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/products/\{id\}}
	\item[Archetype] Document
	\item[Methods] GET, PUT, PATCH
	\item[JSON Format Response/Request] \hfill
\begin{lstlisting}
{
	"id": <int,id> ,
	"name": "<str,productname>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/products}
	\item[Archetype] Collection
	\item[Methods] GET, POST
	\item[Batch Create] Unterstützt
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id> ,
		"name": "<str,productname>"	
		"uri": "<uri,resource>"
	}
]
\end{lstlisting}
\item[JSON Format Request] \hfill
\begin{lstlisting}
[
	{
		"name": "<str,productname>"
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\pagebreak
\subsubsection{Packages}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/packages/\{id\}}
	\item[Archetype] Document
	\item[Methods] GET, PUT, PATCH
	\item[JSON Format Response/Request] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"name": "<str,packagename>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/packages}
	\item[Archetype] Collection
	\item[Methods] GET, POST
	\item[Batch Create] Unterstützt
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id>,
		"name": "<str,packagename>",
		"uri": "<uri,resource>"
	}
]
\end{lstlisting}
	\item[JSON Format Request] \hfill
\begin{lstlisting}
[
	{
		"name": "<str,packagename>"
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/packages/\{id\}/versions}
	\item[Archetype] Readonly Collection
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	<doc,version>
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\pagebreak
\subsubsection{Versions}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/versions/\{id\}}
	\item[Archetype] Document
	\item[Query] \texttt{dept=<int,depth>}
	\item[Methods] GET, PUT, PATCH, DELETE
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"package": "<uri,package>",
	"product": "<uri,product>",
	"release": "<str,release>",
	"securtiy": <int,security>,
	"blacklist": <bool,blacklist>,
	"time": <int,time>
}
\end{lstlisting}
	\item[JSON Format Request] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"package": <int,package-id>,
	"product": <int,product-id>,
	"release": "<str,release>",
	"securtiy": <int,security>,
	"blacklist": <bool,blacklist>,
	"time": <int,time>
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/versions}
	\item[Archetype] Collection
	\item[Filter] \texttt{product-name=<str,product-name>,\\
	product-id=<int,product-id>,\\
	package-name=<str,package-name>,\\
	package-id=<int,package-id>}
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET, POST
	\item[Batch Create] Unterstützt
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id>,
		"package": "<uri,package>",
		"product": "<uri,product>",
		"release": "<str,release>",
		"securtiy": <int,security>,
		"blacklist": <bool,blacklist>,
		"time": <int,time>
		"uri": "<uri,resource>"
	}
]
\end{lstlisting}
	\item[JSON Format Request] \hfill
\begin{lstlisting}
[
	{
		"package": <int,package-id>,
		"product": <int,product-id>,
		"release": "<str,release>",
		"securtiy": <int,security>,
		"blacklist": <bool,blacklist>,
		"time": <int,time>
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\pagebreak
\subsubsection{Identities}
\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/identities/\{id\}}
	\item[Archetype] Document
	\item[Methods] GET, PUT, PATCH
	\item[JSON Format Response/Reques] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"type": <int,type>,
	"value": "<str,value>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/identities}
	\item[Archetype] Collection
	\item[Filter] \texttt{type=<int,type>,\\
	value=<str,value>}
	\item[Methods] GET, POST
	\item[Batch Create] Unterstützt
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id>,
		"type": <int,type>,
		"value": "<str,value>"
		"uri": "<uri,resource>"
	}
]
\end{lstlisting}
	\item[JSON Format Request] \hfill
\begin{lstlisting}
[
	{
		"type": <int,type>,
		"value": "<str,value>"
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\pagebreak
\subsubsection{Devices}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/devices/\{id\}}
	\item[Archetype] Document
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET, PUT, PATCH
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"description": "<str,description>",
	"value": "<str,value>",
	"product": "<uri,product>",
	"created": <int,created>
}
\end{lstlisting}
\item[JSON Format Request] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"description": "<str,description>",
	"value": "<str,value>",
	"product": <int,product-id>,
	"created": <int,created>
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/devices}
	\item[Archetype] Collection
	\item[Filter] \texttt{value=<str,value>,\\
	 product-name=<str,product-name>,\\
	 product-id=<int,product-id>} 
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET, POST
	\item[Batch Create] Unterstützt
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id>,
		"description": "<str,description>",
		"value": "<str,value>",
		"product": "<uri,product>",
		"created": <int,created>,
		"uri": "<uri,resource>"
	}
]
\end{lstlisting}
	\item[JSON Format Request] \hfill
\begin{lstlisting}
[
	{
		"description": "<str,description>",
		"value": "<str,value>",
		"product": <int,product-id>,
		"created": <int,created>
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/device/\{id\}/sessions}
	\item[Archetype] Readonly Collection
	\item[Filter] \texttt{time-from=<int,time>,\\
	time-to=<int,time>}
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET
	\item[Batch Create] Unterstützt
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	<doc,session>
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\pagebreak
\subsubsection{Enforcements}
\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/enforcements/\{id\}}
	\item[Archetype] Readonly Document
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"policy": "<uri,policy>",
	"group": "<uri,group>",
	"rec-fail": <int,rec_fail>,
	"rec-noresult": <int,rec_noresult>", 
	"max-age": <int,max_age>
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/enforcements}
	\item[Archetype] Readonly Collection
	\item[Filter] \texttt{group-id=<int,group-id>,\\
	group-name=<str,group-name>}
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET
	\item[JSON Format] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id>,
		"policy": "<uri,policy>",
		"group": "<uri,group>",
		"rec-fail": <int,rec_fail>,
		"rec-noresult": <int,rec_noresult>", 
		"max-age": <int,max_age>
		"uri": "<uri,resource>"
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/enforcements/\{id\}/workitems}
	\item[Archetype] Readonly Collection
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET
	\item[JSON Format] \hfill
\begin{lstlisting}
[
	<doc,workitem>
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\pagebreak
\subsubsection{Policies}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/policies/\{id\}}
	\item[Archetype] Readonly Document
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"type": <int,type>,
	"name": "<str,name>",
	"argument": "<str,argument>",
	"rec-fail": <int,rec_fail>,
	"rec-noresult": <int,rec_noresult>, 
	"file": "<uri,file>",
	"dir": "<uri,dir>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/policies}
	\item[Archetype] Readonly Collection
	\item[Methods] GET
	\item[JSON Format] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id>,
		"type": <int,type>,
		"name": "<str,name>",
		"argument": "<str,argument>",
		"rec-fail": <int,rec_fail>,
		"rec-noresult": <int,rec_noresult>, 
		"file": "<uri,file>",
		"dir": "<uri,dir>"	
		"uri": "<uri,resource>"
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/policies/\{id\}/enforcements}
	\item[Archetype] Readonly Collection
	\item[Methods] GET
	\item[JSON Format] \hfill
\begin{lstlisting}
[
	<doc,enforcement>
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\pagebreak
\subsubsection{Results}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/results/\{id\}}
	\item[Archetype] Document
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET, PUT, PATCH
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"session": "<uri,session>",
	"policy": "<uri,policy>",
	"rec": <int,rec>,
	"result": "<str,result>"
}
\end{lstlisting}
    \item[JSON Format Request] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"session": <int,session-id>,
	"policy": <int,policy-id>,
	"rec": <int,rec>,
	"result": "<str,result>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/results}
	\item[Archetype] Collection
	\item[Filter] \texttt{policy=<int,policy>}
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET, POST
	\item[Batch Create] Unterstützt
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
    {
	    "id": <int,id>,
	  	"session": "<uri,session>",
    	"policy": "<uri,policy>",
	    "rec": <int,rec>,
	    "result": "<str,result>",
	    "uri": <uri,resource>
    }
]
\end{lstlisting}
	\item[JSON Format Request] \hfill
\begin{lstlisting}
[
    {
	    "session": <int,session-id>,
	    "policy": <int,policy-id>,
	    "rec": <int,rec>,
	    "result": "<str,result>",
    }
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\pagebreak
\subsubsection{Groups}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/groups/\{id\}}
	\item[Archetype] Readonly Document
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"name": "<str,name>",
	"parent": "<uri,group>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/groups}
	\item[Archetype] Readonly Collection
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET
	\item[JSON Format] \hfill
\begin{lstlisting}
[
	{
        "id": <int,id>,
    	"name": "<str,name>",
    	"parent": "<uri,group>"
		"uri": "<uri,resource>"
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/groups/\{id\}/devices}
	\item[Archetype] Collection
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET, POST
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	<doc,device>
]
\end{lstlisting}
	\item[JSON Format Request] \hfill
\begin{lstlisting}
[
	<int,device-id>
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\pagebreak
\subsubsection{Groups\_members}

Keine Ressourcen für Zwischentabellen.

\pagebreak
\subsubsection{Groups\_products\_defaults}

\begin{mdframed}[style=def]
\begin{description}
	\item[URI Path] \texttt{/groups-product-defaults/\{id\}}
	\item[Archetype] Readonly Document
	\item[Methods] GET
	\item[JSON Format] \hfill
\begin{lstlisting}
{
	id : $id$ ,
	group : "$group-uri$",
	product : "$product-uri$"
}
\end{lstlisting}
\end{description}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description}
	\item[URI Path] \texttt{/groups-members}
	\item[Archetype] Collection
	\item[Methods] GET, POST
	\item[JSON Format] \hfill
\begin{lstlisting}
[
	{
		id : $id$ ,
		group : "$group-uri$",
		device : "$device-uri$",
		uri : "$resource-uri$"
	}
]
\end{lstlisting}
\end{description}
\end{mdframed}


\pagebreak
\subsubsection{Files}

\begin{mdframed}[style=def]
\begin{description}
	\item[URI Path] \texttt{/files/\{id\}}
	\item[Archetype] Document
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET, PUT, PATCH
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"name": "<str,name>",
	"dir": "<uri,directory>"
}
\end{lstlisting}
	\item[JSON Format Request] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"name": "<str,name>",
	"dir": <int,directory-id>
}
\end{lstlisting}
\end{description}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/files}
	\item[Archetype] Collection
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET, POST
	\item[Batch Create] Unterstützt
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
    {
	    "id": <int,id>,
	    "name": "<str,name>",
	    "dir": "<uri,directory>",
	    "uri": "<uri,resource>"
    }
]
\end{lstlisting}
	\item[JSON Format Request] \hfill
\begin{lstlisting}
[
    {
	    "id": <int,id>,
	    "name": "<str,name>",
	    "dir": <int,directory-id>,
	    "uri": "<uri,resource>"
    }
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\pagebreak
\subsubsection{Directories}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/directories/\{id\}}
	\item[Archetype] Document
	\item[Methods] GET, PUT, PATCH
	\item[JSON Format Response/Request] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"path": "<str,path>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/directories}
	\item[Archetype] Collection
	\item[Methods] GET, POST
	\item[Batch Create] Unterstützt
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id>,
	    "path": "<str,path>",
	    "uri": <uri,resource>
	}
]
\end{lstlisting}
    \item[JSON Format Request] \hfill
\begin{lstlisting}
[
	{
	    "path": "<str,path>"
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/directories/\{id\}/files}
	\item[Archetype] Readonly Collection
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	<doc,file>
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\pagebreak
\subsubsection{SWID Tags}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/swid-tags/{id}}
	\item[Archetype] Readonly Document
	\item[Query] \texttt{depth=<int,depth>}
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"package-name": "<str,package-name>",
	"version": "<str,version>",
	"unique-id": "<str,unique_id>",
	"entity": {
		"tag-creator": "<uri-entity>",
		"publisher":  "<uri-entity>",
		"licensor": "<uri-entity>"
	},
	"tag-xml": "<xml,swid-tag>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/swid-tags}
	\item[Archetype] Readonly Collection
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	{
		"id": <int,id>,
    	"package-name": "<str,package-name>",
    	"version": "<str,version>",
    	"unique-id": "<str,unique_id>",
    	"entity": {
    		"tag-creator": "<uri-entity>",
    		"publisher":  "<uri-entity>",
    		"licensor": "<uri-entity>"
    	},
    	"tag-xml": "<xml,swid-tag>",
    	"uri": <uri,resource>
    	
	}
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\pagebreak
\subsubsection{Entities}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/swid-entities/{id}}
	\item[Archetype] Readonly Document
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
{
	"id": <int,id>,
	"name": "<str,name>",
	"regid": "<str,regid>"
}
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/swid-entities}
	\item[Archetype] Readonly Collection
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
	{
	    "id": <int,id>,
	    "name": "<str,name>",
	    "regid": "<str,regid>",
	    "uri": <uri,resource>
    }
]
\end{lstlisting}
\end{description*}
\end{mdframed}

\begin{mdframed}[style=def]
\begin{description*}
	\item[URI Path] \texttt{/swid-entities/\{id\}/swid-tags}
	\item[Archetype] Readonly Collection
	\item[Methods] GET
	\item[JSON Format Response] \hfill
\begin{lstlisting}
[
    <doc,swid-tag>
]
\end{lstlisting}
\end{description*}
\end{mdframed}


\end{document}
