\chapter{SWID Generator}

% {{{ Requirements -----------------------------------------------------------%

\section{Requirements}

\subsection{Zweck}

Der SWID Generator soll ein kleines Programm für Linux-Systeme sein, welches aus
den Informationen in Paket Management Systemen SWID Tags generiert.

\subsection{Nichtfunktionale Anforderungen}

\begin{itemize}
		\item Als Implementationsprache wird Python verwendet.
		\item Es sollen möglichst wenig Abhängigkeiten zu Drittkomponenten wie
			Libraries/Frameworks entstehen.
		\item Die Software soll einfach zu installieren sein, beispielsweise durch
			Upload in den Python Package Index ($\rightarrow$ \texttt{pip install
			swid-generator}) oder durch Erstellen von \texttt{.deb}- und
			\texttt{.rpm}-Paketen.
		\item Als Quelle der Paketinformationen sollen Paketmanager wie DPKG und RPM
			verwendet werden.
\end{itemize}

\subsection{Use Cases}

Nachfolgend sind sind die identifizierten Use Cases für die Client Komponenten
des SWID-Generator aufgeführt.

Dabei werden die folgen drei Systemkomponenten berücksichtigt, welche
gegenseitig über die Standardeingabe und -ausgabe kommunizieren.

\vspace{1em}

\begin{figure}[H]
	\centering
	\input{tikz/swid-generator-aktoren}
	\caption{SWID Generator: Systemkomponenten}
	\label{img:swid-generator-aktoren}
\end{figure}

\subsubsection{UC01: Erkennung des Paketmanagers}

\begin{usecase}
\hline
\textbf{Akteur} & strongSwan IMC \\
\hline
\textbf{Story} &
Der Akteur weiss nicht welcher Paketmanager auf dem Zielsystem verwendet wird.
Der SWID Generator soll den verwendeten Paketmanager automatisch erkennen. \\
\hline
\textbf{Standard Szenario} &
Der SWID Generator erkennt den System-Paketmanager automatisch. \\
\hline
\textbf{Alternatives Szenario} &
Mittels optionalem Parameter kann der zu verwendende Paketmanager definiert
werden, die automatische Erkennung wird dadurch übersteuert. \\
\hline
\end{usecase}


\subsubsection{UC02: Software ID Generierung}

\begin{usecase}
\hline
\textbf{Akteur} & strongSwan IMC \\
\hline
\textbf{Story} &
Der Akteur will Software IDs aller installierten Pakete generieren. Das Format
dieser IDs folgt dem ISO Draft 19770-2-5 \cite{iso19770-2-5} und besteht
aus der Regid des Tag Creators sowie der Unique ID des Tags. \\
\hline
\textbf{Standard Szenario} &
Alle Software IDs werden generiert und auf der Standardausgabe durch Newlines
(\texttt{\textbackslash{n}}) getrennt ausgegeben. Es wird eine Software ID pro Zeile
ausgegeben. \\
\hline
\textbf{Alternatives Szenario} &
Die Trennzeichen zur Ausgabe der Software IDs können mittels optionalem
Parameter spezifiziert werden. \\
\hline
\end{usecase}


\subsubsection{UC03: SWID Tag Generierung}

\begin{usecase}
\hline
\textbf{Akteur} & strongSwan IMC \\
\hline
\textbf{Story} &
Der Akteur will SWID Tags aller installierten Pakete generieren. Das Format
dieser Dokumente folgt dem ISO Draft 19770-2-5 \cite{iso19770-2-5}. Für jedes
installierte Paket wird ein eigenes XML Dokument generiert. \\
\hline
\textbf{Standard Szenario} &
Alle Tags werden generiert und auf der Standardausgabe durch Newlines
(\texttt{\textbackslash{n}}) getrennt ausgegeben. Es wird ein Tag pro Zeile
ausgegeben. Die Attribute des Tag Creators werden mit vordefinierten
Standardwerten befüllt. Es sind nur die minimal benötigten Elemente und
Attribute enthalten. \\
\hline
\textbf{Alternatives Szenario 1} &
Die Attribute des Tag Creators können mittels optionalen Parametern spezifiziert
werden. \\
\hline
\textbf{Alternatives Szenario 2} &
Die Trennzeichen zur Ausgabe der Tags können mittels optionalem Parameter
spezifiziert werden. \\
\hline
\textbf{Alternatives Szenario 3} &
Zu Debug-Zwecken können die Tags mittels optionalem Parameter in einer
eingerückten und einfacher lesbaren Form ausgegeben werden (\enquote{pretty
printing}). \\
\hline
\textbf{Alternatives Szenario 4} &
Mittels optionalem Parameter können die XML Tags mit einem Payload-Element
versehen werden, welches für jedes Paket die darin enthaltenen Dateien
auflistet. \\
\hline
\end{usecase}


\subsubsection{UC04: Targeted Request}

\begin{usecase}
\hline
\textbf{Akteur} & strongSwan IMC \\
\hline
\textbf{Story} &
Der Akteur möchte nur den SWID Tag eines bestimmten Paketes erhalten. \\
\hline
\textbf{Standard Szenario} &
Mittels Parameter kann dem Generator ein Filterwert angegeben werden,
um einen bestimmten Tag herauszufiltern. Als Filterwert gibt es 2 Varianten:
Entweder über den Package Name oder über die Software ID. \\
\hline
\textbf{Alternatives Szenario 1} &
Die Attribute des Tag Creators können mittels optionalen Parametern spezifiziert
werden. \\
\hline
\textbf{Alternatives Szenario 2} &
Zu Debug-Zwecken können die Tags mittels optionalem Parameter in einer
eingerückten und einfacher lesbaren Form ausgegeben werden (\enquote{pretty
printing}). \\
\hline
\textbf{Alternatives Szenario 3} &
Mittels optionalem Parameter können die XML Tags mit einem Payload-Element
versehen werden, welches für jedes Paket die darin enthaltenen Dateien
auflistet. \\
\hline
\end{usecase}

% }}}

% {{{ Paketmanager -----------------------------------------------------------%

\section{Paketmanager}
\label{swidgenerator:paketmanager}

Im Rahmen dieser Arbeit wurde die Unterstützung für drei der am weitesten
verbreiteten Paketverwaltungssysteme (DPKG, RPM und Pacman) implementiert. Damit
werden 8 der 10 führenden Linux- und BSD-Distributionen gemäss
DistroWatch.com\cite{distrowatch:2014} abgedeckt.

Ein Paketmanager verwaltet unter anderem alle verfügbaren und installierten
Softwarepakete inklusive Meta-Informationen wie Paketname, Version oder
Installationsstatus.

\subsection{DPKG}

DPKG\footnote{\url{https://alioth.debian.org/projects/dpkg}} (Abkürzung für
\textit{Debian Package}) ist die Basis der Paketverwaltung in Debian und in
verwandten Distributionen wie Ubuntu.

\textbf{Liste installierter Pakete abfragen}

\begin{bashcode}
dpkg-query --show --showformat='${Package}\t${Version}\t${Status}\n'
\end{bashcode}

\textbf{Dateien zu Paket abfragen}

\begin{bashcode}
dpkg-query --listfiles <package-name>
\end{bashcode}

\textbf{Bemerkungen}

Entfernte DPKG Pakete können einen sogenannten RC Status haben. Dieser liegt
vor, wenn ein Paket deinstalliert wurde, aber die Konfigurationsdateien auf dem
System belassen wurden. Die \texttt{---show} Option liefert auch diese Pakete.
Der Status ist in der Ausgabe als \texttt{"deinstall ok config-files"}
ersichtlich, entsprechende Pakete können so nachträglich herausgefiltert werden.


\subsection{RPM}

RPM\footnote{\url{https://rpm.org}} (Abkürzung für \textit{Red Hat Package
Manager}) ist der Standard-Paketmanager für Red Hat Linux Systeme sowie
zahlreichen verwandten Distributionen wie openSUSE, Mandriva und Fedora.

\textbf{Liste installierter Pakete abfragen}

\begin{bashcode}
rpm -qa --queryformat %{name}\t%{version}-%{release}
\end{bashcode}

\textbf{Dateien zu Paket abfragen}

\begin{bashcode}
rpm -ql <package-name>
\end{bashcode}


\subsection{Pacman}

Pacman\footnote{\url{https://www.archlinux.org/pacman/}} ist der Paketmanager
unter Arch Linux und allen Derivaten wie Manjaro Linux oder Chakra.

\textbf{Liste installierter Pakete abfragen}

\begin{bashcode}
pacman -Q --color never
\end{bashcode}

\textbf{Dateien zu Paket abfragen}

\begin{bashcode}
pacman -Ql <package-name>
\end{bashcode}

% }}}

% {{{ Architektur ------------------------------------------------------------%

\section{Architektur}

\subsection{Übersicht}

Der SWID Generator wurde komplett in Python geschrieben und nutzt keine externen
Libraries. Es wird sowohl Python 2 wie auch Python 3 unterstützt.

Der Quellcode ist modular aufgebaut, gewisse Komponenten wurden in separate
Subpackages aufgeteilt:

\begin{figure}[H]
	\centering
	\input{tikz/generator-paketdiagramm}
	\caption{Aufteilung SWID Generator in Python Packages}
\end{figure}

Das Hauptpackage -- \texttt{swid\_generator} -- enthält folgende Module:

\begin{itemize}
	\item \texttt{main.py}: Der Einstiegspunkt in das Programm
	\item \texttt{argparser.py}: Klassen und Funktionen um
		Kommandozeilenargumente zu parsen
	\item \texttt{print\_functions.py}: Funktionen um Tag- und
		Software-ID-Generatoren auf die Standardausgabe auszugeben
	\item \texttt{package\_info.py}: DTO\footnote{Data Transfer Object, eine
		Klasse die kein Eigenverhalten aufweist sondern lediglich Daten in
		einem Objekt bündelt.}-Klassen für Dateien und Softwarepakete
	\item \texttt{exceptions.py}: Eigene Fehlerklassen
	\item \texttt{settings.py}: Globale Variablen, wie \zb
		\texttt{DEFAULT\_ENTITY\_NAME}
	\item \texttt{meta.py}: Metainformationen zum Generator, wie \zb der
		Programmname, die Lizenz oder die Version
\end{itemize}

Die zwei Subpackages sind für Input respektive Output zuständig. Im
\texttt{environments} Package sind die Environment-Klassen für die verschiedenen
Paketmanager enthalten. Die Klassen greifen auf die jeweiligen Paketdatenbanken
zu und geben diese Informationen an das Hauptprogramm zurück. Auch die
Environment-Registry befindet sich in diesem Package. Mehr dazu im Abschnitt
\ref{swidgenerator:architektur:environments}.

Das \texttt{generators} Package enthält die nötigen Funktionen um aus den (vom
entsprechenden Environment zurückgegebenen) Paketinformationen die dazugehörigen
Software-ID Strings oder SWID XML Tags zu generieren. Diese Funktionen sind als
Python
Generators\footnote{\url{https://docs.python.org/2/tutorial/classes.html\#generators}}
implementiert, die einzelnen Einträge können also schon während der Generierung
laufend ausgegeben werden. Mehr dazu im Abschnitt
\ref{swidgenerator:architektur:printers}.

Als Einstiegspunkt in den SWID Generator dient das \texttt{main.py} Modul. Um
das Programm direkt aus dem Quellcode-Ordner heraus zu starten, sollte Python
mit der \texttt{-m} Option und dem vollständigen Modulpfad gestartet werden:

\begin{bashcode}
python -m swid_generator.main
\end{bashcode}

Wenn das Programm über pip oder setup.py installiert wird (siehe
\autoref{swidgenerator:architektur:deployment}), kann es natürlich auch direkt
über den Programmnamen aufgerufen werden:

\begin{bashcode}
swid_generator
\end{bashcode}

\subsection{Ablauf}

\subsubsection{Initialisierung}
\label{swidgenerator:architektur:initialisierung}

Wenn der SWID Generator gestartet wird, beginnt die Code-Ausführung im
\texttt{main.py} Modul. Zuerst müssen alle Kommandozeilen-Argumente verarbeitet
werden. Danach müssen die modular aufgebauten Environment Klassen registriert
werden. Mit diesen Informationen muss entschieden werden, welches Environment
dass effektiv verwendet werden soll -- entweder durch den Benutzer definiert
oder durch eine automatische Packetmanager-Erkennung.

Der Ablauf ist wie folgt:

\begin{enumerate}
	\item Die Environment Registry
		(\ref{swidgenerator:architektur:environments:registry}) wird initialisiert.
	\item Alle verfügbaren Environment Klassen
		(\ref{swidgenerator:architektur:environments}) werden der Registry
		übergeben.
	\item Der Argument Parser wird mit einer Referenz auf die Registry instanziert.
	\item Die Parser Instanz parst mithilfe des \texttt{argparse} Moduls aus der
		Python Stanardbibliothek die Kommandozeilen-Argument und generiert daraus ein
		\enquote{Options}-Objekt. \item Dieses Objekt wird nun der Environment Registry
		übergeben. Diese kann mit den Informationen darin die geeignete Environment
		Klasse finden und an das Hauptprogramm zurückgeben. Das Environment kann per
		Kommandozeilen-Argument vorgegeben werden, andernfalls wird es automatisch
		detektiert.
\end{enumerate}

In der folgenden Abbildung ist dieser Ablauf als UML Sequenzdiagramm
dargestellt:

\begin{figure}[H]
	\centering
	\input{tikz/generator-sequenzdiagramm-init}
	\caption{Sequenzdiagramm: Initialisierung}
\end{figure}

\subsubsection{Generierung}
\label{swidgenerator:architektur:generierung}

Nachdem nun im Abschnitt \ref{swidgenerator:architektur:initialisierung} alle
nötigen Informationen gesammelt wurden, kann nun die Hauptarbeit geschehen: Die
Generierung der Daten aus den Paketmanager-Informationen. Ob SWID Tags oder
Software-IDs generiert werden, ist abhängig vom ersten Kommandozeilenargument,
welches entweder \texttt{swid} oder \texttt{software-id} sein kann.

\begin{enumerate}
	\item Zuerst werden mithilfe des SWID Tag Generators
		(\ref{swidgenerator:architektur:generatoren}) die gewünschen Tags aus
		der Paketmanager-Datenbank geholt.
	\item Die zurückgegebenen Tags werden mithilfe der entsprechenden
		Print-Funktionen (\ref{swidgenerator:architektur:printers}) auf die
		Standardausgabe ausgegeben.
	\item Falls im ganzen Programmablauf keine Fehler aufgetreten sind, wird
		das Programm nun mit dem Status Code 0 (=keine Fehler) beendet.
\end{enumerate}

Dieser Ablauf ist im folgenden UML Sequenzdiagramm visualisiert:

\begin{figure}[H]
	\centering
	\input{tikz/generator-sequenzdiagramm-generierung}
	\caption{Sequenzdiagramm: Generierung}
\end{figure}


\subsection{Implementationsdetails}

\subsubsection{Environments}
\label{swidgenerator:architektur:environments}

Die Environments sind das Kernstück des SWID-Generators, denn sie greifen auf
den System-Paketmanager zu und bereiten die Liste der installierten Pakete für
die weitere Verarbeitung auf.

Wie bereits im Abschnitt \ref{swidgenerator:paketmanager} erwähnt, bietet der
SWID Generator zum aktuellen Zeitpunkt Unterstützung für drei Paketmanager an.
Damit das Tool in Zukunft auch auf bisher noch nicht unterstützten Systemen wie
Slackware Linux oder FreeBSD einsatzfähig ist, haben wir grossen Wert darauf
gelegt, dass man möglichst einfach die Unterstützung für neue Environments
hinzufügen kann.

Um dieses Ziel zu erreichen, ist eine einheitliche Schnittstelle für die
Environment-Klassen essentiell. Wie es in Python üblich
ist\cite{contracts:2003}, wird dafür ein Ansatz mit impliziten Contracts
anstelle von explizit ausprogrammierten Interfaces verwendet. Dieser
Architektur-Ansatz ist auch als \textit{Duck Typing} bekannt.

Damit eine Klasse ein gültiges Environment darstellt, benötigt sie die folgenden
fünf Methoden:

\begin{itemize}
	\item \texttt{get\_package\_list()}: Gibt eine Liste von
		\texttt{swid\_generator.\-package\_info.\-PackageInfo} Instanzen zurück,
		welche die installierten Softwarepakete auf dem aktuellen System
		repräsentiert.
	\item \texttt{get\_files\_for\_package(package\_name)}: Akzeptiert einen
		Paket-Namen und gibt eine Liste von
		\texttt{swid\_generator.\-package\_info.\-FileInfo}-Instanzen zurück, welche
		die zu einem Softwarepaket gehörigen Dateien repräsentiert.
	\item \texttt{is\_installed()}: Prüft, ob der repräsentierte Paketmanager auf
		dem aktuellen System installiert ist oder nicht. Dies kann beispielseweise
		getan werden, indem geprüft wird ob die wichtigen Executables (\zb
		\texttt{dpkg-query} bei DPKG) vorhanden sind.
	\item \texttt{get\_architecture()}: Gibt den System-Architekturtyp (\zb
		\texttt{x86\_64} oder \texttt{i386}) zurück.
	\item \texttt{get\_os\_string()}: Gibt den Bezeichner der aktuellen
		Betriebssystem-Distribution zurück (\zb \texttt{debian\_7.4} oder
		\texttt{fedora\_19}).
\end{itemize}

Da viele Environments gemeinsam benötigte Funktionalität aufweisen --
beispielsweise die Überprüfung ob eine vom Paketmanager gemeldete Datei auch
wirklich auf dem System vorhanden ist -- haben wir diese in eine Basisklasse
namens \texttt{CommonEnvironment} ausgegliedert. Diese kann -- aber muss nicht
-- von einem Environment erweitert werden.

Die aktuell vorhandenen Environment-Klassen sind folgendermassen organisiert:

\begin{figure}[H]
	\centering
	\resizebox{\textwidth}{!}{%
		\input{tikz/environment-klassendiagramm}
	}
	\caption{Die Environment-Klassen}
	\label{img:environment-klassendiagramm}
\end{figure}


\subsubsection{Die Registry}
\label{swidgenerator:architektur:environments:registry}

\subsubsection{Generatoren}
\label{swidgenerator:architektur:generatoren}

\subsubsection{Printers}
\label{swidgenerator:architektur:printers}


\subsubsection{Python 3 Kompatibilität}


% }}}

% {{{ Ergebnisse -------------------------------------------------------------%

\section{Ergebnisse}

- Beispiel
- Speed

% }}}

% {{{ Qualitätsmanagement ----------------------------------------------------%

\section{Qualitätsmanagement}
\label{swidgenerator:architektur:qa}

% }}}

% {{{ Packaging --------------------------------------------------------------%

\section{Packaging}

- Setup.py
- Manifest.in
- meta.py

% }}}

% {{{ Deployment -------------------------------------------------------------%

\section{Deployment}
\label{swidgenerator:architektur:deployment}

% }}}
