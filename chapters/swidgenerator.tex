\chapter{SWID Generator}

\section{Requirements}

\subsection{Zweck}

Der SWID Generator soll ein kleines Programm für Linux-Systeme sein, welches aus
den Informationen in Paket Management Systemen SWID Tags generiert.

\subsection{Nichtfunktionale Anforderungen}

\begin{itemize}
		\item Als Implementationsprache wird Python verwendet.
		\item Es sollen möglichst wenig Abhängigkeiten zu Drittkomponenten wie
			Libraries/Frameworks entstehen.
    \item Die Software soll einfach zu installieren sein, beispielsweise durch
			Upload in den Python Package Index ($\rightarrow$ \texttt{pip install
			swid-generator}) oder durch Erstellen von \texttt{.deb}- und
			\texttt{.rpm}-Paketen.
		\item Als Quelle der Paketinformationen sollen Paketmanager wie DPKG und RPM
			verwendet werden.
\end{itemize}

\subsection{Use Cases}

Nachfolgend sind sind die identifizierten Use Cases für die Client Komponenten
des SWID-Generator aufgeführt.

Dabei werden die folgen drei Systemkomponenten berücksichtigt, welche
gegenseitig über die Standardeingabe und -ausgabe kommunizieren.

\vspace{1em}

\begin{figure}[H]
	\centering
	\input{tikz/swid-generator-aktoren}
	\caption{SWID Generator: Systemkomponenten}
	\label{img:swid-generator-aktoren}
\end{figure}

\subsubsection{UC01: Erkennung des Paketmanagers}

\begin{usecase}
\hline
\textbf{Akteur} & strongSwan IMC \\
\hline
\textbf{Story} &
Der Akteur weiss nicht welcher Paketmanager auf dem Zielsystem verwendet wird.
Der SWID Generator soll den verwendeten Paketmanager automatisch erkennen. \\
\hline
\textbf{Standard Szenario} &
Der SWID Generator erkennt den System-Paketmanager automatisch. \\
\hline
\textbf{Alternatives Szenario} &
Mittels optionalem Parameter kann der zu verwendende Paketmanager definiert
werden, die automatische Erkennung wird dadurch übersteuert. \\
\hline
\end{usecase}


\subsubsection{UC02: Software ID Generierung}

\begin{usecase}
\hline
\textbf{Akteur} & strongSwan IMC \\
\hline
\textbf{Story} &
Der Akteur will Software IDs aller installierten Pakete generieren. Das Format
dieser IDs folgt dem ISO Draft 19770-2-5 \cite{iso19770-2-5} und besteht
aus der Regid des Tag Creators sowie der Unique ID des Tags. \\
\hline
\textbf{Standard Szenario} &
Alle Software IDs werden generiert und auf der Standardausgabe durch Newlines
(\texttt{\textbackslash{n}}) getrennt ausgegeben. Es wird eine Software ID pro Zeile
ausgegeben. \\
\hline
\textbf{Alternatives Szenario} &
Die Trennzeichen zur Ausgabe der Software IDs können mittels optionalem
Parameter spezifiziert werden. \\
\hline
\end{usecase}


\subsubsection{UC03: SWID Tag Generierung}

\begin{usecase}
\hline
\textbf{Akteur} & strongSwan IMC \\
\hline
\textbf{Story} &
Der Akteur will SWID Tags aller installierten Pakete generieren. Das Format
dieser Dokumente folgt dem ISO Draft 19770-2-5 \cite{iso19770-2-5}. Für jedes
installierte Paket wird ein eigenes XML Dokument generiert. \\
\hline
\textbf{Standard Szenario} &
Alle Tags werden generiert und auf der Standardausgabe durch Newlines
(\texttt{\textbackslash{n}}) getrennt ausgegeben. Es wird ein Tag pro Zeile
ausgegeben. Die Attribute des Tag Creators werden mit vordefinierten
Standardwerten befüllt. Es sind nur die minimal benötigten Elemente und
Attribute enthalten. \\
\hline
\textbf{Alternatives Szenario 1} &
Die Attribute des Tag Creators können mittels optionalen Parametern spezifiziert
werden. \\
\hline
\textbf{Alternatives Szenario 2} &
Die Trennzeichen zur Ausgabe der Tags können mittels optionalem Parameter
spezifiziert werden. \\
\hline
\textbf{Alternatives Szenario 3} &
Zu Debug-Zwecken können die Tags mittels optionalem Parameter in einer
eingerückten und einfacher lesbaren Form ausgegeben werden (\enquote{pretty
printing}). \\
\hline
\textbf{Alternatives Szenario 4} &
Mittels optionalem Parameter können die XML Tags mit einem Payload-Element
versehen werden, welches für jedes Paket die darin enthaltenen Dateien
auflistet. \\
\hline
\end{usecase}


\subsubsection{UC04: Targeted Request}

\begin{usecase}
\hline
\textbf{Akteur} & strongSwan IMC \\
\hline
\textbf{Story} &
Der Akteur möchte nur den SWID Tag eines bestimmten Paketes erhalten. \\
\hline
\textbf{Standard Szenario} &
Mittels Parameter kann dem Generator ein Filterwert angegeben werden,
um einen bestimmten Tag herauszufiltern. Als Filterwert gibt es 2 Varianten:
Entweder über den Package Name oder über die Software ID. \\
\hline
\textbf{Alternatives Szenario 1} &
Die Attribute des Tag Creators können mittels optionalen Parametern spezifiziert
werden. \\
\hline
\textbf{Alternatives Szenario 2} &
Zu Debug-Zwecken können die Tags mittels optionalem Parameter in einer
eingerückten und einfacher lesbaren Form ausgegeben werden (\enquote{pretty
printing}). \\
\hline
\textbf{Alternatives Szenario 3} &
Mittels optionalem Parameter können die XML Tags mit einem Payload-Element
versehen werden, welches für jedes Paket die darin enthaltenen Dateien
auflistet. \\
\hline
\end{usecase}


\section{Paketmanager}

Im Rahmen dieser Arbeit wurde die Unterstützung für drei der am weitesten
verbreiteten Paketverwaltungssysteme (DPKG, RPM und Pacman) implementiert. Damit
werden 8 der 10 führenden Linux- und BSD-Distributionen gemäss
DistroWatch.com\cite{distrowatch:2014} abgedeckt.

\subsubsection{DPKG}

DPKG\footnote{\url{https://alioth.debian.org/projects/dpkg}} (Abkürzung für
\textit{Debian Package}) ist die Basis der Paketverwaltung in Debian und in
verwandten Distributionen wie Ubuntu. DPKG verwaltet unter anderem alle
installierten Software-Pakete inklusive Meta-Informationen. Diese Paketliste
kann mit \texttt{dpkg-query} abgefragt werden.

\textbf{Liste installierter Pakete abfragen}

\begin{bashcode}
dpkg-query --show --showformat='${Package}\t${Version}\t${Status}\n'
\end{bashcode}

\textbf{Dateien zu Paket abfragen}

\begin{bashcode}
dpkg-query --listfiles <package-name>
\end{bashcode}

\textbf{Bemerkungen}

Entfernte DPKG Pakete können einen sogenannten RC Status haben. Dieser liegt
vor, wenn ein Paket deinstalliert wurde, aber die Konfigurationsdateien auf dem
System belassen wurden. Die \texttt{---show} Option liefert auch diese Pakete.
Der Status ist in der Ausgabe als \texttt{"deinstall ok config-files"}
ersichtlich, entsprechende Pakete können so nachträglich herausgefiltert werden.


\subsubsection{RPM}

RPM\footnote{\url{https://rpm.org}} (Abkürzung für \textit{Red Hat Package
Manager}) ist der Standard-Paketmanager für Red Hat Linux Systeme sowie
zahlreichen verwandten Distributionen wie openSUSE, Mandriva und Fedora.

\textbf{Liste installierter Pakete abfragen}

\begin{bashcode}
rpm -qa --queryformat %{name}\t%{version}-%{release}
\end{bashcode}

\textbf{Dateien zu Paket abfragen}

\begin{bashcode}
rpm -ql <package-name>
\end{bashcode}


\subsubsection{Pacman}

Pacman\footnote{\url{https://www.archlinux.org/pacman/}} ist der Paketmanager
unter Arch Linux und allen Derivaten wie Manjaro Linux oder Chakra.

\textbf{Liste installierter Pakete abfragen}

\begin{bashcode}
pacman -Q --color never
\end{bashcode}

\textbf{Dateien zu Paket abfragen}

\begin{bashcode}
pacman -Ql <package-name>
\end{bashcode}


\section{Architektur}

\subsection{Initialisierung}

\begin{figure}[H]
	\centering
	\input{tikz/generator-sequenzdiagramm-init}
	\caption{Sequenzdiagramm: Initialisierung}
	\label{img:generator-sequenzdiagramm-init}
\end{figure}

\subsection{Generierung}

\begin{figure}[H]
	\centering
	\input{tikz/generator-sequenzdiagramm-generierung}
	\caption{Sequenzdiagramm: Generierung}
	\label{img:generator-sequenzdiagramm-generierung}
\end{figure}
