\section{Erweiterungen}

\subsection{Qualität}

\subsubsection{Aufteilung in Apps}

\subsubsection{Continous Integration}

\subsubsection{Testing und Code Standards (PEP8)}

\subsubsection{Konsequente verwendung von URL names}

\subsubsection{Konsequente Frontend Validierung}


\subsubsection{Konsistente Datums verwendung UTC}

\subsubsection{Depolyment Dokus, Vagrant, Ansible}

\subsection{Features}

\subsubsection{Aufteilung der Zugriffsrechte}
Um die Informationen in strongTNC zu Präsentationszwecken zugänglich zu machen,
ohne dass Änderungen vorgenommen werden können, weder absichtlich noch aus
Versehen, soll eine Readonly Rolle eingeführt werden.

In einem ersten Schritt soll ein Modell mit zwei Rollen eingeführt werden. Eine
Rolle für den readonly Zugriff und eine für den Vollzugriff. Die Rollen sollen,
so wie es gegenwärtig implementiert ist, nicht personalisiert sein. Die
Möglichkeit, den Login zu personalisieren sollte nicht grundsätzlich
ausgeschlossen werden, jedoch steht die Implementation eines nicht
personalisierten readonly Zugriffs im Vordergrund.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Das Django Webframework hat ein vollständiges Authentication- und
Permission-System integriert. Damit lassen sich komplexe Permission-Szenarien
abbilden, jedoch besteht auch die Möglichkeit nur Teile daraus zu verwenden und
so ein einfacheres Rollen-Modell zu simulieren.

Da keine personalisierten Logins benötigt sind, werden zwei technische Benutzer
erstellt, die für die beiden Rollen eingesetzt werden. Die Namen der beiden Benutzer sind 
 \texttt{admin-user} und \texttt{readonly-user}. Dem
\texttt{admin-user} Benutzer wird eine \texttt{write\_access} Berechtigung erteilt, diese
kann in den Views mittels Django-Internem \texttt{@permission\_required()}
Decorator geprüft werden.

Diese Variante der Umsetzung erlaubt es, mit wenig Aufwand personaliserte Logins
einzuführen. Für die Verwaltung der Benutzer stellt Django ein Admin-Interface
zur Verfügung, die Benutzerverwaltung muss nicht selber entwickelt werden.

In den Templates können die Zugriffsrechte über das \texttt{perms} Objekt im
\texttt{Context} geprüft werden:

\begin{pythoncode}
{% if 'auth.write_access' in perms %}
    <p>Read-write access.</p>
{% endif %}
\end{pythoncode}

Die zusätzliche Implementation eines Templatetags erleichtert die Steuerung von HTML Formularelementen deren Bedienung nur für schreibberechtigte Benutzer erlaubt sein soll:

\begin{pythoncode}
@register.simple_tag(takes_context=True)
def input_editability(context):
    perms = context.get('perms', [])
    if 'auth.write_access' not in perms:
        return 'disabled="disabled"'
    return ''
\end{pythoncode}

Die Anwendung sieht wie folgt aus:

\begin{pythoncode}
<input type="text"name="name" value="{{ group }}" {% input_editability %} />
\end{pythoncode}

Diese Umsetzung folgt einer Variation, dem in \cite{posa1} vorgeschlagenen Pattern \enquote{Full Access With Errors}. Alle Funktionen sind stets für den Benutzer sichtbar. Dadurch kann das User Interface einheitlich gestaltet werden und vermeidet auf diese Weise mögliche Verwirrungen. Diejenigen Elemente, die der Benutzer nicht bearbeiten darf, werden deaktiviert. 

Um die beiden benötigten Benutzer initial zu erstellen, wurde das Django
Management-Kommando \texttt{setpassword} angepasst. Das Kommando erstellt direkt
die beiden Benutzer und erlaubt es die Passwörter interaktiv oder per Parameter
festzulegen.

\paragraph{Alternativen} \hspace{0px} \\
Als Alternative zum Django Permission-System könnten auch die standardmässig
vorhandenen Flags \texttt{user.is\_admin} und \texttt{user.is\_staff} verwendet
werden. Dies wäre bedeutend einfacher zu implementieren, jedoch ist die Lösung
nicht ausbaufähig. Deshalb wird das Permission-System bevorzugt.

\subsubsection{Nachladen von grossen Datenmengen}
strongTNC muss grossen mit Datenmengen umgehen können. Wenn Datei-Messungen
durchgeführt- oder SWID Tags erfasst werden, ist beispielsweise die Zahl der
erfassten Dateien schnell im fünfstelligen Bereich. Wenn einzelne dieser Dateien
ausgewählt werden sollen, muss verhindert werden, dass immer die gesamte Menge
der Daten geladen wird.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Die gesuchten Datensätze werden mittels inkrementeller Suche per Ajax
nachgeladen.

Die Ajax Endpunkte werden mit Hilfe von
\enquote{Dajax-ice}\footnote{\url{http://www.dajaxproject.com/}} realisiert.
\enquote{Dajax-ice} übernimmt sämtliche Vorkehrungen die nötig sind um mit Django
einen Ajax Request zu behandeln. So werden zum Beispiel benötigte HTTP Header
automatisch gesetzt und geprüft. Ausserdem generiert \enquote{Dajax-ice} für
jeden Ajax Endpunkt eine Javascript Funktion, welche die benötige Infrastruktur bereitstellt um Ajax Requests auszuführen.
\\
Ein Ajax Endpunkt kann wie eine übliche Django View entwickelt werden.

\begin{listing}
\caption{Beispiel eines Ajax Endpunktes}
\begin{pythoncode}
@dajaxice_register
@ajax_login_required
def directories_autocomplete(request, search_term):
    dirs = Directory.objects.filter(path__icontains=search_term)
    results = {'results': [{'id': d.id, 'directory': d.path} for d in dirs]}
    return json.dumps(results)
\end{pythoncode}
\end{listing}

Der Javascript-Aufruf für diesen Endpunkt sieht wie folgt aus:

\begin{jscode}
Dajaxice.apps.filesystem.directories_autocomplete(callback, {search_term: 'system'});
\end{jscode} 

Damit bei der inkrementellen Suche nicht bei jedem Tastenanschlag ein Request
abgesetzt wird, wurde ein Wrapper implementiert, welcher erst einen Request
absetzt wenn für eine bestimmte Zeit keine Eingabe mehr gemacht wurde.

<TODO: Evtl. sequenz diagramm oder code? Erwähnen, dass das filtern der files schwierig ist?>

\paragraph{Langlaufende Operationen / Fehlerbehandlung}
Asynchrone Aufrufe bringen zwei wesentliche Probleme mit sich. Zum einen kann es sein, dass Fehler auftreten, wie z.B Timeouts, die der Benutzer nicht bemerkt. Um zum anderen, muss für den Benutzer ersichtlich sein, ob Datenübertragungen im Hintergrund anstehen und falls ja, wann diese erfolgreich abgeschlossen sind. Speziell für langlaufende Operationen durch Datenbankintensive Abfragen oder grosse Datenmengen können Antwortzeiten im Sekundenbereich entstehen. \\
Zu diesem Zweck wurde eine Proxy Komponente \cite{gamma1994design} implementiert, welche Anstelle des eigentlichen Dajax-ice Aufrufes eingesetzt wird. Komponenten, deren Inhalte per Ajax nachladen werden, werden vom Proxy mit einem Statusindikator besetzt. Zusätzlich wurde ein globaler Statusindikator eingeführt, der anzeigt, ob mindestens eine asynchrone Datenübertragung stattfindet.\\
Treten Fehler bei einer Ajax Datenübertragung auf, wird der Benutzer mittels Alert Box über den Fehler informiert.

\subsubsection{Ajax Pagination}
Um in grossen Datenmengen zu navigieren mit der Möglichkeit diese auch zu
filtern wurde die bestehende statische Pagination durch eine dyamische Ajax
basierte Version ausgetauscht. Diese hatte die Anforderung, dass es möglich sein
sollte jegliche Art von Daten seitenweise auszuliefern, sowie die Daten zuvor zu
Filtern. Um dies zu erreichen wurde eine generische Paginiation implementiert,
welche es erlaubt, die zu unterteilenden Daten mittels \enquote{Strategy
Pattern}\cite{gamma1994design} aufzubereiten.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Die Implementation der Paginierung besteht aus den folgenden fünf Teilen:
\begin{enumerate}
	\item Javascript Frontend Komponente
	\item Template Tag, Templates und HTML Markup
	\item Generischer Ajax Endpunkt
	\item Individuelle Konfiguration pro Pagination Instanz
	\item \enquote{List Producer} für die Datenaufbereitung, wiederverwendbar
\end{enumerate}

\autoref{paginationSequence} zeigt den Grobablauf, für das Anfordern einer
neuen Seite.

\begin{figure}[H]
	\centering
	\input{tikz/pagination-sequenzdiagramm-grob}
	\label{paginationSequence}
	\caption{Sequenzdiagramm: Grobablauf}
\end{figure}

Die Idee hinter diesem Aufbau ist, dass Teile die sich zwischen den einzelnen
Instanzen unterscheiden einerseits austauschbar und trotzdem wiederverwendbar
sind. In diesem Setup sind das die Templates die je nach Inhalt einer Liste oder
Tabelle variieren und die sogenannten \enquote{Producer} welche die Daten
sammeln und aufbereiten, wenn jedoch an zwei stellen die gleichen Daten benötigt
werden, können die Producer wiederverwendet werden.
Producer sind eine Implementation des \enquote{Strategy Pattern}, jeder Instanz
muss ein bestimmtes Interface erfüllen und kann darum ausgetauscht werden.\\
Eine Implementation eines Producers sieht wie folgt aus:

\begin{pythoncode}
def swid_files_list_producer(from_idx, to_idx, filter_query, dynamic_params, static_params=None):
    if not dynamic_params:
        return []
    tag_id = dynamic_params['tag_id']
    return Tag.objects.get(pk=tag_id).files.all()[from_idx:to_idx]
\end{pythoncode}

Für generische List Producer, welche lediglich eine Liste von Objekten eines
bestimmten Models liefert, existiert zusätzlich eine \enquote{Factory}:

\begin{pythoncode}
swid_producer_factory = ProducerFactory(Tag, 'unique_id__icontains')
swid_producer_factory.list()
\end{pythoncode}

Um einen Pagination Block in eine Seite einzubinden existiert ein Template Tag.
Dieser inkludiert einen vorgegeben HTML Block und überträgt allfällige
Konfigurationen in Daten-Attribute des HTML Blocks.\\
Ein so eingebundener Block wird durch die Javascript Komponente gefunden und die
Pagination wird initialisiert.

Konfiguriert wird eine Pagination Instanz über ein \enquote{Config-Dictionary}.
Dieses muss an zwei Stellen referenziert werden. Einerseits wird dieses im
Template Tag angegeben, andererseits muss die Konfiguration im Ajax Endpunkt
registriert werden.

\subsubsection{Erstellen von Files und Versions}
Bisher war es nicht möglich über das Oberfläche von strongTNC in der
File-Ansicht neue Files zu erstellen. Ebenso konnte man in der Package-Ansicht
zwar neue Packages erstellen, nicht aber neue Versionen.\\
Beide fehlenden Features wurden erstellt. Umgesetzt wurde dies nach dem Muster
der bestehenden Views, so dass sich ein Benutzer dank einer konsistenten
Oberfläche schnell zurecht findet.

\subsubsection{Models für MySQL Support erstellt}
\paragraph{Empfehlung für Wechsel der Datenbank}
Durch die angesprochene enge Kopplung von strongSwan und strongTNC durch eine gemeinsame Datenbank, bedingen Anpassungen des Datenbankschemas Änderungen an allen Komponenten.
Desweiteren ist zu erwarten, dass für grössere Installationen SQLite zu leichtgewichtig wird.
Optimierungen und Profiling sind sehr eingeschränkt, zu dem wird keine referenzielle Integrität unterstützt.
\paragraph{Generierung des Datenbankschemas}
Django unterstütz diverse Datenbankbackends \footnote{\url{https://docs.djangoproject.com/en/dev/ref/databases/}}, so unter anderem MySQL, PostgreSQL, MSSQL und das zur Zeit verwendete SQLite.
Wir empfehlen das SQLite Backend möglichst bald durch eine vollausgewachsene Datenbank zu ersetzen. Aus diesem Grund haben wir die Models dahingehend angepasst, dass Sie dem aktuellen Dantebankschema entsprechen. 
Der Django ORM kann daraus Datenbankspezifisches SQL DDL generieren, und so die Migration erheblich erleichtern.

\subsubsection{Split der Configfiles}

\subsubsection{Django Admin-Interface}
