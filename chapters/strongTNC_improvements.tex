\section{Erweiterungen}

\subsection{Qualität}

\subsubsection{Aufteilung in mehrere Django Apps}

Bereits in der Analyse (Abschnitt \ref{analyse:stand}) fiel uns auf, dass
die bestehende Codebasis von strongTNC als einzelne Django App namens
\texttt{tncapp} umgesetzt wurde. Innerhalb der App waren alle Models in einer
einzigen Datei enthalten (\texttt{models.py}), während die Views in mehrere
thematisch gruppierte Dateien aufgeteilt wurden (\texttt{device\_views.py},
\texttt{product\_views.py}, etc).

Diese Aufteilung der Views deutet darauf hin, dass die \texttt{tncapp} App für
mehrere thematische Bereiche zuständig ist, welche in der Codebasis separariert
werden könnten und sollten. Die Aufteilung in mehrere Python-Dateien ist jedoch
in Django Projekten der falsche Weg um dies zu erreichen. Stattdessen bietet
Django für solche Fälle das Konzept einer App an.

Eine App ist ein Verzeichnis innerhalb eines Django Projektes, welches seine eigenen
Models, Views und eventuell Templates enthält. Die Apps werden in der
Projektweiten \texttt{setting.py} registriert. Ein einzelnes Projekt lässt sich
so in mehrere kleine MVC Container aufteilen.

Die Voraussetzung dafür, dass eine Aufteilung einer Codebasis in mehrere Apps
Sinn ergibt, ist eine hohe Kohäsion der Codebasis innerhalb einer App. Das führt
dazu, dass eine App \enquote{pluggable} wird und einfach aktiviert- und
deaktiviert werden kann. Die Separierung von hochkohäsivem Code in mehrere Apps
führt automatisch zu tiefer Kopplung (\cite[p.~232--237]{larman2002applying})
und dadurch zu wartbarerem Code.

Aus obengenannten Gründen haben wir die bestehende monolithische App in folgende
zehn moderat bis hoch kohäsive Apps aufgeteilt:

\begin{itemize}
	\item core: Enthält zentrale Elemente die von fast allen Apps verwendet
		werden, wie beispielsweise das \texttt{Session} Model oder die
		\texttt{WorkItemType} Klasse.
	\item front: Enthält alle Elemente zum darstellen der Seite, welche nicht
		App-spezifisch sind. Beispiele hierfür sind das Base-Template, der
		\texttt{highlight} Template Filter oder der \texttt{paging} Ajax Endpoint.
	\item auth: Enthält Hilfsfunktionen, Mixins und Template Tags im Bezug auf die
		Authentisierung und Berechtigungsprüfung.
	\item api: Enthält Hilfsfunktionen und Mixins im Bezug auf die API.
	\item devices: Enthält Models und Code im Bezug auf Geräte, wie
		\texttt{Product}, \texttt{Device} und \texttt{Group}.
	\item filesystem: Enthält Models und Code im Bezug auf das Dateisystem
		(\texttt{File}, \texttt{Directory}, etc).
	\item packages: Enthält Models und Code im Bezug auf Softwarepakete und deren
		verfügbaren Versionen.
	\item policies: Enthält Models und Code im Bezug auf Policies und deren
		Durchsetzung mithilfe von Enforcements.
	\item swid: Enthält Models und Code im Bezug auf die SWID Integration in
		strongTNC.
	\item tpm: Enthält Models im Bezug auf die TPM Integration in
		strongTNC. Diese App bietet aktuell noch keine Funktionalität.
\end{itemize}

\subsubsection{Continous Integration}

TODO Danilo

\subsubsection{Deployment Dokus, Vagrant, Ansible}

TODO Danilo

\subsubsection{Weitere Punkte}
\begin{description}
\item[Code Standards (PEP8)] Damit die Einhaltung der PEP8 Richtlinien
garantiert ist, wurde eine entsprechende Prüfung in den Build Prozess
integriert. Dadurch gilt ein Build als fehlgeschlagen, falls die Richtlinien
nicht vollständig eingehalten wurden.

\item[Vermeidung von Hardcoded URLs] Gemäss Empfehlung des Django Frameworks
soll das verwenden von absoluten URLs in Templates und Views vermieden werden.
Anstelle sollen URLs nur einmal, in der URLConf, konfiguriert und danach via
Rückwärtssuche durch den Namen aufgelöst werden. Auf diese Weise können zentral
Änderungen an URLs vorgenommen werden, ohne Templates oder Views anpassen zu
müssen.

\item[Konsequente Frontend Validierung] Die bestehende Frontend Validierung
wurde an diversen Orten nicht konsequent oder fehlerhaft eingesetzt. Diese
Mängel wurden behoben und damit die Validierung vereinheitlicht.

\item[Konsistente Datums verwendung UTC]
TODO Danilo
\end{description}

\subsection{Features}

\subsubsection{Aufteilung der Zugriffsrechte}
Um die Informationen in strongTNC zu Präsentationszwecken zugänglich zu machen,
ohne dass Änderungen vorgenommen werden können, weder absichtlich noch aus
Versehen, soll eine Readonly Rolle eingeführt werden.

In einem ersten Schritt soll ein Modell mit zwei Rollen eingeführt werden. Eine
Rolle für den readonly Zugriff und eine für den Vollzugriff. Die Rollen sollen,
so wie es gegenwärtig implementiert ist, nicht personalisiert sein. Die
Möglichkeit, den Login zu personalisieren sollte nicht grundsätzlich
ausgeschlossen werden, jedoch steht die Implementation eines nicht
personalisierten readonly Zugriffs im Vordergrund.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Das Django Webframework hat ein vollständiges Authentication- und
Permission-System integriert. Damit lassen sich komplexe Permission-Szenarien
abbilden, jedoch besteht auch die Möglichkeit nur Teile daraus zu verwenden und
so ein einfacheres Rollen-Modell zu simulieren.

Da keine personalisierten Logins benötigt sind, werden zwei technische Benutzer
erstellt, die für die beiden Rollen eingesetzt werden. Die Namen der beiden Benutzer sind 
 \texttt{admin-user} und \texttt{readonly-user}. Dem
\texttt{admin-user} Benutzer wird eine \texttt{write\_access} Berechtigung erteilt, diese
kann in den Views mittels Django-Internem \texttt{@permission\_required()}
Decorator geprüft werden.

Diese Variante der Umsetzung erlaubt es, mit wenig Aufwand personaliserte Logins
einzuführen. Für die Verwaltung der Benutzer stellt Django ein Admin-Interface
zur Verfügung, die Benutzerverwaltung muss nicht selber entwickelt werden.

In den Templates können die Zugriffsrechte über das \texttt{perms} Objekt im
\texttt{Context} geprüft werden:

\begin{pythoncode}
{% if 'auth.write_access' in perms %}
    <p>Read-write access.</p>
{% endif %}
\end{pythoncode}

Die zusätzliche Implementation eines Templatetags erleichtert die Steuerung von HTML Formularelementen deren Bedienung nur für schreibberechtigte Benutzer erlaubt sein soll:

\begin{pythoncode}
@register.simple_tag(takes_context=True)
def input_editability(context):
    perms = context.get('perms', [])
    if 'auth.write_access' not in perms:
        return 'disabled="disabled"'
    return ''
\end{pythoncode}

Die Anwendung sieht wie folgt aus:

\begin{pythoncode}
<input type="text"name="name" value="{{ group }}" {% input_editability %} />
\end{pythoncode}

Diese Umsetzung folgt einer Variation, dem in \cite{posa1} vorgeschlagenen Pattern \enquote{Full Access With Errors}. Alle Funktionen sind stets für den Benutzer sichtbar. Dadurch kann das User Interface einheitlich gestaltet werden und vermeidet auf diese Weise mögliche Verwirrungen. Diejenigen Elemente, die der Benutzer nicht bearbeiten darf, werden deaktiviert. 

Um die beiden benötigten Benutzer initial zu erstellen, wurde das Django
Management-Kommando \texttt{setpassword} angepasst. Das Kommando erstellt direkt
die beiden Benutzer und erlaubt es die Passwörter interaktiv oder per Parameter
festzulegen.

\paragraph{Alternativen} \hspace{0px} \\
Als Alternative zum Django Permission-System könnten auch die standardmässig
vorhandenen Flags \texttt{user.is\_admin} und \texttt{user.is\_staff} verwendet
werden. Dies wäre bedeutend einfacher zu implementieren, jedoch ist die Lösung
nicht ausbaufähig. Deshalb wird das Permission-System bevorzugt.

\subsubsection{Nachladen von grossen Datenmengen}
strongTNC muss grossen mit Datenmengen umgehen können. Wenn Datei-Messungen
durchgeführt- oder SWID Tags erfasst werden, ist beispielsweise die Zahl der
erfassten Dateien schnell im fünfstelligen Bereich. Wenn einzelne dieser Dateien
ausgewählt werden sollen, muss verhindert werden, dass immer die gesamte Menge
der Daten geladen wird.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Die gesuchten Datensätze werden mittels inkrementeller Suche per Ajax
nachgeladen.

Die Ajax Endpunkte wurden mit Hilfe der \enquote{Dajax-ice}\footnote{\url{http://www.dajaxproject.com/}} Django Erweiterung realisiert.
\enquote{Dajax-ice} stellt die nötigen Bibliotheken bereit, um Ajax Endpunkte wie gewöhnliche Views zu implementieren. So werden zum Beispiel benötigte HTTP Header
automatisch gesetzt und geprüft. Ausserdem generiert \enquote{Dajax-ice} Javascript Funktionen, welche die benötige Infrastruktur clientseitig bereitstellen, um Ajax Requests auszuführen.
\\

In Listing \autoref{strongTNC:ajaxendpoint} ist die Beispielimplementation eines Ajax Endpoints zu sehen. Um auch bei Ajax Anfragen eine Authentifizierung zu erzwingen, wurde ein eigener Decorator (\texttt{@ajax\_login\_required}) erstellt. 
\begin{listing}
\caption{Beispiel eines Ajax Endpunktes}
\label{strongTNC:ajaxendpoint}
\begin{pythoncode}
@dajaxice_register
@ajax_login_required
def directories_autocomplete(request, search_term):
    dirs = Directory.objects.filter(path__icontains=search_term)
    results = {'results': [{'id': d.id, 'directory': d.path} for d in dirs]}
    return json.dumps(results)
\end{pythoncode}
\end{listing}

Clientseitig kann der Endpunkt wie folgt mit Javascript angesprochen werden:
\begin{listing}
\caption{Absenden eines Ajax Requests}
\begin{jscode}
Dajaxice.apps.filesystem.directories_autocomplete(callback, {search_term: 'system'});
\end{jscode} 
\end{listing}

Damit bei der inkrementellen Suche nicht bei jedem Tastenanschlag ein Request
abgesetzt wird, wurde ein Verzögerungsmechanismus implementiert, welcher erst einen Request
absetzt, wenn für eine bestimmte Zeit keine Eingabe mehr gemacht wurde (angelehnt an Nagle's Algorithmus \cite{nagle1984congestion}).
Durch die Minimierung der Anzahl HTTP Request, wird auch die Anzahl der teilweise komplexen und zeitintensiven Abfragen auf die Datenbank vermindert.

\paragraph{Langlaufende Operationen / Fehlerbehandlung}
Asynchrone Aufrufe bringen zwei wesentliche Probleme mit sich. Zum einen kann es sein, dass Fehler auftreten, wie z.B Timeouts, die der Benutzer nicht bemerkt. Um zum anderen, muss für den Benutzer ersichtlich sein, ob Datenübertragungen im Hintergrund anstehen und falls ja, wann diese erfolgreich abgeschlossen sind. Speziell für langlaufende Operationen durch Datenbankintensive Abfragen oder grosse Datenmengen können Antwortzeiten im Sekundenbereich entstehen. \\
Zu diesem Zweck wurde eine Proxy Komponente \cite{gamma1994design} implementiert, welche Anstelle des eigentlichen Dajax-ice Aufrufes eingesetzt wird. Komponenten, deren Inhalte per Ajax nachladen werden, werden vom Proxy mit einem Statusindikator besetzt. Zusätzlich wurde ein globaler Statusindikator eingeführt, der anzeigt, ob mindestens eine asynchrone Datenübertragung stattfindet.\\
Treten Fehler bei einer Ajax Datenübertragung auf, wird der Benutzer mittels Alert Box über den Fehler informiert.

\subsubsection{Ajax Pagination} Um in grossen Datenmengen zu navigieren wurde
die bestehende statische Pagination durch eine dynamische, Ajax basierte
Version, ausgetauscht. Mit dem Ziel, jegliche Art von Daten seitenweise auszuliefern, sowie die Daten filtern zu können. 
Bei der Architektur der Pagingkomponente wurde darauf geachtet, dass sie einfach wiederverwendet werden kann. Der Inhalt, der seitenweise ausgeliefert werden soll, wurde von der Pagination entkoppelt und kann mittels Strategy (\enquote{Strategy Pattern}\cite{gamma1994design}) festgelegt werden.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Die Implementation der Paginierung besteht aus den folgenden fünf Teilen:
\begin{enumerate}
	\item Javascript Frontend Komponente
	\item Template Tag, Templates und HTML Markup
	\item Generischer Ajax Endpunkt
	\item Individuelle Konfiguration pro Pagination Instanz
	\item \enquote{List Producer} für die Datenaufbereitung, wiederverwendbar
\end{enumerate}

\autoref{paginationSequence} zeigt den Grobablauf, beim dynamischen Anfordern einer
neuen Seite.

\begin{figure}[H]	
	\centering
	\input{tikz/pagination-sequenzdiagramm-grob}
	\caption{Sequenzdiagramm: Grobablauf}
	\label{paginationSequence}
\end{figure}


\begin{description}
\item[HtmlPage]
Auf der HTML Seite werden Container definiert, welche mit später den Seiteninhalten befüllt werden. Die Container können entweder direkt in HTML  (Listing~\ref{paging:container})
definiert werden oder mittels, des eigens dafür kreierten, Template Tags (Listing~\ref{paging:templatetag}) generiert werden.

\begin{listing}[H]
\caption{Paging Div Container}
\label{paging:container}
\begin{htmlcode}
<div class="ajax-paged"
     data-config="regid_list_config"
     data-args="{}"
     data-initial="True"
     data-urlparams="True"
     data-filter="True">
	[...]
	<div class="paged-content"></div>
	[...]
</div>
\end{htmlcode}
\end{listing}

\begin{listing}
\caption{Verwendung eines \enquote{Paged Blocks}}
\label{paging:templatetag}
\begin{pythoncode}
{% paged_block config_name="regid_list_config" with_filter=True %}
\end{pythoncode}
\end{listing}


\item[Javascript]
Eine Aufgabe der Javascript Komponente ist das Auslesen aller Paged Block Konfigurationen aus der Html Seite. Gefunden werden diese durch die gemeinsame \texttt{ajax-paged} CSS Klasse. Es können so mehrere Paged Block Komponenten pro Seite definiert werden. Für jeden der gefunden Paging Container wird ein Pager Objekt instanziert, welches für die Kommunikation mit dem AjaxEndpoint verantwortlich ist. Nach erfolgreicher Kommunikation mit dem AjaxEndpoint wird der zurückgelieferte HTML Block in den entsprechenden Container geladen.

\item [AjaxEndpoint]
Der AjaxEndpoint nimmt die Requests entgegen und kann anhand des übergebenen Konfigurationsnamens die zugehörige Konfiguration laden.
Die Konfiguration beinhaltet ein Producer und ein Template.
Die Datengenerierung wird an den Producer delegiert und die Daten anschliessend als Kontext verwendet, um das Template zu HTML Code zu rendern.
Durch diese Separierung wird eine hohe Wiederverwendbarkeit erreicht. Für verschiedene Datenquellen (Producer) können dieselben Templates und umgekehrt verwendet werden.

\begin{listing}
\caption{Beispiel einer Paging Config}
\begin{pythoncode}
regid_list_paging = {
    'template_name': 'front/paging/default_list',
    'list_producer': regid_producer_factory.list(),
    'stat_producer': regid_producer_factory.stat(),
    'url_name': 'swid:regid_detail',
    'page_size': 50,
}
\end{pythoncode}
\end{listing}

\item[Producer]
Die eigentliche Datenaufbereitung, in der Regel Datenbankabfragen, inkl. Slicing und Filtering wird im Producer definiert.

\end{description}

Die Idee hinter diesem Aufbau ist, dass Bestandteile, die sich zwischen den einzelnen
Instanzen unterscheiden, austauschen und wiederverwenden lassen. In diesem Setup sind das die Templates, die für die Darstellung von Daten verantwortlich sind und die sogenannten \enquote{Producer}, welche Daten sammeln und aufbereiten.
Durch ein gemeinsames Producer Interface (Implementation des \enquote{Strategy Pattern}), können Producer sehr flexibel ausgetauscht und wiederverwendet werden.\\
Eine konkrete Implementation eines Producers ist in Listing~\ref{paging:producer} zu sehen.

\begin{listing}
\caption{Beispielimplementation eines Producers}
\label{paging:producer}
\begin{pythoncode}
def swid_files_list_producer(from_idx, to_idx, filter_query, dynamic_params, static_params=None):
    if not dynamic_params:
        return []
    tag_id = dynamic_params['tag_id']
    return Tag.objects.get(pk=tag_id).files.all()[from_idx:to_idx]
\end{pythoncode}
\end{listing}

Für generische List Producer, welche lediglich eine Liste von Objekten eines bestimmten Models liefern, wurde eine eine \enquote{Factory} erstellt:

\begin{listing}
\caption{Producer Factory}
\begin{pythoncode}
swid_producer_factory = ProducerFactory(Tag, 'unique_id__icontains')
swid_producer_factory.list()
\end{pythoncode}
\end{listing}

\paragraph{Zusammenfassung} \hspace{0pt} \\
Um einen Pagination Block in eine Seite einzubinden, existiert ein Template Tag. Dieser inkludiert einen vorgegeben HTML Block und überträgt allfällige
Konfigurationen in Daten-Attribute des HTML Blocks.\\
Ein so eingebundener Block wird durch die Javascript Komponente gefunden und die
Pagination wird initialisiert.

Konfiguriert wird eine Pagination Instanz über ein \enquote{Config-Dictionary}.
Dieses muss an zwei Stellen referenziert werden. Einerseits wird dieses im
Template Tag angegeben, andererseits muss die Konfiguration im Ajax Endpunkt
registriert werden.

\subsubsection{Models für MySQL Support erstellt}
\paragraph{Empfehlung für Wechsel der Datenbank}
Durch die angesprochene enge Kopplung von strongSwan und strongTNC, durch eine gemeinsame Datenbank, bedingen Anpassungen des Datenbankschemas Änderungen an allen Komponenten.
Desweiteren ist zu erwarten, dass für grössere Installationen SQLite zu leichtgewichtig wird.
Optimierungen und Profiling sind sehr eingeschränkt, zu dem wird keine referenzielle Integrität unterstützt.
\paragraph{Generierung des Datenbankschemas}
Django unterstütz diverse Datenbankbackends \footnote{\url{https://docs.djangoproject.com/en/dev/ref/databases/}}, so unter anderem MySQL, PostgreSQL, MSSQL und das zur Zeit verwendete SQLite.
Wir empfehlen das SQLite Backend möglichst bald durch eine vollausgewachsene Datenbank zu ersetzen. Aus diesem Grund haben wir die Models dahingehend angepasst, dass Sie dem aktuellen Dantebankschema entsprechen. 
Der Django ORM kann daraus Datenbankspezifisches SQL DDL generieren, und so die Migration erheblich erleichtern.

\subsubsection{Split der Configfiles}
TODO Danilo

\subsubsection{Weitere Punkte}
\begin{description}
\item[Django Admin-Interface] Django bietet die Möglichkeit die Datenbank über
ein automatisch generiertes Admin-Interface zu verwalten. Auf diese Weise
können, potentiell fehleranfällige, Datenmanipulationen per SQL vermieden
werden. Die Models wurden mit den nötigen Metadaten erweitert, damit dieses
Feature aktiviert werden konnte.

\item[Erstellen von Files und Versions] Bisher war es nicht möglich über das
Oberfläche von strongTNC neue Files und neue Versionen zu erstellen. Die
Ansichten wurden um diese Funktionalität ergänzt.

\item[Verknüpfung von Daten in Views] Die Views wurden durch sinnvolle
Verknüpfungen ergänzt. Die  Verknüpfungen waren bereits in der Datenbank
vorhanden, jedoch in den Views nicht direkt ersichtlich, so zum Beispiel welche
Enforcements einer Gruppe zugeordnet sind.

\item[URL Hash Parameter] Um Parameter in der URL abzulegen und auszulesen,
wurde eine Javascript Hilfsbibliothek erstellt. Die Bibliothek erlaubt es, die
Parameter in der URL abzulegen ohne einen Reload auszulösen. Ausserdem kann auf
Änderungen Eventbasiert (Observer Pattern \cite{gof94}) reagiert werden.
Änderungen welche mittels Ajax ausgelöst und somit keinen Reload zur folge
haben, können so über die URL und die Browser History zugänglich gemacht werden.
\end{description}




