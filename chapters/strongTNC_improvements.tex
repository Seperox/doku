\section{Erweiterungen}

\subsection{Qualität}

\subsubsection{Aufteilung in Apps}
TODO Danilo
\subsubsection{Continous Integration}
TODO Danilo
\subsubsection{Deployment Dokus, Vagrant, Ansible}
TODO Danilo

\subsubsection{Weitere Punkte}
\begin{description}
\item[Code Standards (PEP8)] Damit die Einhaltung der PEP8 Richtlinien
garantiert ist, wurde eine entsprechende Prüfung in den Build Prozess
integriert. Dadurch gilt ein Build als fehlgeschlagen, falls die Richtlinien
nicht vollständig eingehalten wurden.

\item[Vermeidung von Hardcoded URLs] Gemäss Empfehlung des Django Frameworks
soll das verwenden von absoluten URLs in Templates und Views vermieden werden.
Anstelle sollen URLs nur einmal, in der URLConf, konfiguriert und danach via
Rückwärtssuche durch den Namen aufgelöst werden. Auf diese Weise können zentral
Änderungen an URLs vorgenommen werden, ohne Templates oder Views anpassen zu
müssen.

\item[Konsequente Frontend Validierung] Die bestehende Frontend Validierung
wurde an diversen Orten nicht konsequent oder fehlerhaft eingesetzt. Diese
Mängel wurden behoben und damit die Validierung vereinheitlicht.

\item[Konsistente Datums verwendung UTC]
TODO Danilo
\end{description}

\subsection{Features}

\subsubsection{Aufteilung der Zugriffsrechte}
Um die Informationen in strongTNC zu Präsentationszwecken zugänglich zu machen,
ohne dass Änderungen vorgenommen werden können, weder absichtlich noch aus
Versehen, soll eine Readonly Rolle eingeführt werden.

In einem ersten Schritt soll ein Modell mit zwei Rollen eingeführt werden. Eine
Rolle für den readonly Zugriff und eine für den Vollzugriff. Die Rollen sollen,
so wie es gegenwärtig implementiert ist, nicht personalisiert sein. Die
Möglichkeit, den Login zu personalisieren sollte nicht grundsätzlich
ausgeschlossen werden, jedoch steht die Implementation eines nicht
personalisierten readonly Zugriffs im Vordergrund.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Das Django Webframework hat ein vollständiges Authentication- und
Permission-System integriert. Damit lassen sich komplexe Permission-Szenarien
abbilden, jedoch besteht auch die Möglichkeit nur Teile daraus zu verwenden und
so ein einfacheres Rollen-Modell zu simulieren.

Da keine personalisierten Logins benötigt sind, werden zwei technische Benutzer
erstellt, die für die beiden Rollen eingesetzt werden. Die Namen der beiden Benutzer sind 
 \texttt{admin-user} und \texttt{readonly-user}. Dem
\texttt{admin-user} Benutzer wird eine \texttt{write\_access} Berechtigung erteilt, diese
kann in den Views mittels Django-Internem \texttt{@permission\_required()}
Decorator geprüft werden.

Diese Variante der Umsetzung erlaubt es, mit wenig Aufwand personaliserte Logins
einzuführen. Für die Verwaltung der Benutzer stellt Django ein Admin-Interface
zur Verfügung, die Benutzerverwaltung muss nicht selber entwickelt werden.

In den Templates können die Zugriffsrechte über das \texttt{perms} Objekt im
\texttt{Context} geprüft werden:

\begin{pythoncode}
{% if 'auth.write_access' in perms %}
    <p>Read-write access.</p>
{% endif %}
\end{pythoncode}

Die zusätzliche Implementation eines Templatetags erleichtert die Steuerung von HTML Formularelementen deren Bedienung nur für schreibberechtigte Benutzer erlaubt sein soll:

\begin{pythoncode}
@register.simple_tag(takes_context=True)
def input_editability(context):
    perms = context.get('perms', [])
    if 'auth.write_access' not in perms:
        return 'disabled="disabled"'
    return ''
\end{pythoncode}

Die Anwendung sieht wie folgt aus:

\begin{pythoncode}
<input type="text"name="name" value="{{ group }}" {% input_editability %} />
\end{pythoncode}

Diese Umsetzung folgt einer Variation, dem in \cite{posa1} vorgeschlagenen Pattern \enquote{Full Access With Errors}. Alle Funktionen sind stets für den Benutzer sichtbar. Dadurch kann das User Interface einheitlich gestaltet werden und vermeidet auf diese Weise mögliche Verwirrungen. Diejenigen Elemente, die der Benutzer nicht bearbeiten darf, werden deaktiviert. 

Um die beiden benötigten Benutzer initial zu erstellen, wurde das Django
Management-Kommando \texttt{setpassword} angepasst. Das Kommando erstellt direkt
die beiden Benutzer und erlaubt es die Passwörter interaktiv oder per Parameter
festzulegen.

\paragraph{Alternativen} \hspace{0px} \\
Als Alternative zum Django Permission-System könnten auch die standardmässig
vorhandenen Flags \texttt{user.is\_admin} und \texttt{user.is\_staff} verwendet
werden. Dies wäre bedeutend einfacher zu implementieren, jedoch ist die Lösung
nicht ausbaufähig. Deshalb wird das Permission-System bevorzugt.

\subsubsection{Nachladen von grossen Datenmengen}
strongTNC muss grossen mit Datenmengen umgehen können. Wenn Datei-Messungen
durchgeführt- oder SWID Tags erfasst werden, ist beispielsweise die Zahl der
erfassten Dateien schnell im fünfstelligen Bereich. Wenn einzelne dieser Dateien
ausgewählt werden sollen, muss verhindert werden, dass immer die gesamte Menge
der Daten geladen wird.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Die gesuchten Datensätze werden mittels inkrementeller Suche per Ajax
nachgeladen.

Die Ajax Endpunkte wurden mit Hilfe der \enquote{Dajax-ice}\footnote{\url{http://www.dajaxproject.com/}} Django Erweiterung realisiert.
\enquote{Dajax-ice} stellt die nötigen Bibliotheken bereit, um Ajax Endpunkte wie gewöhnliche Views zu implementieren. So werden zum Beispiel benötigte HTTP Header
automatisch gesetzt und geprüft. Ausserdem generiert \enquote{Dajax-ice} Javascript Funktionen, welche die benötige Infrastruktur clientseitig bereitstellen, um Ajax Requests auszuführen.
\\

In Listing \autoref{strongTNC:ajaxendpoint} ist die Beispielimplementation eines Ajax Endpoints zu sehen. Um auch bei Ajax Anfragen eine Authentifizierung zu erzwingen, wurde ein eigener Decorator (\texttt{@ajax\_login\_required}) erstellt. 
\begin{listing}
\caption{Beispiel eines Ajax Endpunktes}
\label{strongTNC:ajaxendpoint}
\begin{pythoncode}
@dajaxice_register
@ajax_login_required
def directories_autocomplete(request, search_term):
    dirs = Directory.objects.filter(path__icontains=search_term)
    results = {'results': [{'id': d.id, 'directory': d.path} for d in dirs]}
    return json.dumps(results)
\end{pythoncode}
\end{listing}

Clientseitig kann der Endpunkt wie folgt mit Javascript angesprochen werden:
\begin{listing}
\caption{Absenden eines Ajax Requests}
\begin{jscode}
Dajaxice.apps.filesystem.directories_autocomplete(callback, {search_term: 'system'});
\end{jscode} 
\end{listing}

Damit bei der inkrementellen Suche nicht bei jedem Tastenanschlag ein Request
abgesetzt wird, wurde ein Verzögerungsmechanismus implementiert, welcher erst einen Request
absetzt, wenn für eine bestimmte Zeit keine Eingabe mehr gemacht wurde (angelehnt an Nagle's Algorithmus \cite{nagle1984congestion}).
Durch die Minimierung der Anzahl HTTP Request, wird auch die Anzahl der teilweise komplexen und zeitintensiven Abfragen auf die Datenbank vermindert.
So erfolgt beispielsweise beim filtern von Dateien auf Datenbanklevel ein Join zwischen der Files und Directories Tabelle.

\paragraph{Langlaufende Operationen / Fehlerbehandlung}
Asynchrone Aufrufe bringen zwei wesentliche Probleme mit sich. Zum einen kann es sein, dass Fehler auftreten, wie z.B Timeouts, die der Benutzer nicht bemerkt. Um zum anderen, muss für den Benutzer ersichtlich sein, ob Datenübertragungen im Hintergrund anstehen und falls ja, wann diese erfolgreich abgeschlossen sind. Speziell für langlaufende Operationen durch Datenbankintensive Abfragen oder grosse Datenmengen können Antwortzeiten im Sekundenbereich entstehen. \\
Zu diesem Zweck wurde eine Proxy Komponente \cite{gamma1994design} implementiert, welche Anstelle des eigentlichen Dajax-ice Aufrufes eingesetzt wird. Komponenten, deren Inhalte per Ajax nachladen werden, werden vom Proxy mit einem Statusindikator besetzt. Zusätzlich wurde ein globaler Statusindikator eingeführt, der anzeigt, ob mindestens eine asynchrone Datenübertragung stattfindet.\\
Treten Fehler bei einer Ajax Datenübertragung auf, wird der Benutzer mittels Alert Box über den Fehler informiert.

\subsubsection{Ajax Pagination}
Um in grossen Datenmengen zu navigieren mit der Möglichkeit diese auch zu
filtern wurde die bestehende statische Pagination durch eine dyamische Ajax
basierte Version ausgetauscht. Diese hatte die Anforderung, dass es möglich sein
sollte jegliche Art von Daten seitenweise auszuliefern, sowie die Daten zuvor zu
Filtern. Um dies zu erreichen wurde eine generische Paginiation implementiert,
welche es erlaubt, die zu unterteilenden Daten mittels \enquote{Strategy
Pattern}\cite{gamma1994design} aufzubereiten.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Die Implementation der Paginierung besteht aus den folgenden fünf Teilen:
\begin{enumerate}
	\item Javascript Frontend Komponente
	\item Template Tag, Templates und HTML Markup
	\item Generischer Ajax Endpunkt
	\item Individuelle Konfiguration pro Pagination Instanz
	\item \enquote{List Producer} für die Datenaufbereitung, wiederverwendbar
\end{enumerate}

\autoref{paginationSequence} zeigt den Grobablauf, für das Anfordern einer
neuen Seite.

\begin{figure}[H]	
	\centering
	\input{tikz/pagination-sequenzdiagramm-grob}
	\caption{Sequenzdiagramm: Grobablauf}
	\label{paginationSequence}
\end{figure}

Die Idee hinter diesem Aufbau ist, dass Teile die sich zwischen den einzelnen
Instanzen unterscheiden einerseits austauschbar und trotzdem wiederverwendbar
sind. In diesem Setup sind das die Templates die je nach Inhalt einer Liste oder
Tabelle variieren und die sogenannten \enquote{Producer} welche die Daten
sammeln und aufbereiten, wenn jedoch an zwei stellen die gleichen Daten benötigt
werden, können die Producer wiederverwendet werden.
Producer sind eine Implementation des \enquote{Strategy Pattern}, jeder Instanz
muss ein bestimmtes Interface erfüllen und kann darum ausgetauscht werden.\\
Eine Implementation eines Producers sieht wie folgt aus:

\begin{pythoncode}
def swid_files_list_producer(from_idx, to_idx, filter_query, dynamic_params, static_params=None):
    if not dynamic_params:
        return []
    tag_id = dynamic_params['tag_id']
    return Tag.objects.get(pk=tag_id).files.all()[from_idx:to_idx]
\end{pythoncode}

Für generische List Producer, welche lediglich eine Liste von Objekten eines
bestimmten Models liefert, existiert zusätzlich eine \enquote{Factory}:

\begin{pythoncode}
swid_producer_factory = ProducerFactory(Tag, 'unique_id__icontains')
swid_producer_factory.list()
\end{pythoncode}

Um einen Pagination Block in eine Seite einzubinden existiert ein Template Tag.
Dieser inkludiert einen vorgegeben HTML Block und überträgt allfällige
Konfigurationen in Daten-Attribute des HTML Blocks.\\
Ein so eingebundener Block wird durch die Javascript Komponente gefunden und die
Pagination wird initialisiert.

Konfiguriert wird eine Pagination Instanz über ein \enquote{Config-Dictionary}.
Dieses muss an zwei Stellen referenziert werden. Einerseits wird dieses im
Template Tag angegeben, andererseits muss die Konfiguration im Ajax Endpunkt
registriert werden.

\subsubsection{Models für MySQL Support erstellt}
\paragraph{Empfehlung für Wechsel der Datenbank}
Durch die angesprochene enge Kopplung von strongSwan und strongTNC durch eine gemeinsame Datenbank, bedingen Anpassungen des Datenbankschemas Änderungen an allen Komponenten.
Desweiteren ist zu erwarten, dass für grössere Installationen SQLite zu leichtgewichtig wird.
Optimierungen und Profiling sind sehr eingeschränkt, zu dem wird keine referenzielle Integrität unterstützt.
\paragraph{Generierung des Datenbankschemas}
Django unterstütz diverse Datenbankbackends \footnote{\url{https://docs.djangoproject.com/en/dev/ref/databases/}}, so unter anderem MySQL, PostgreSQL, MSSQL und das zur Zeit verwendete SQLite.
Wir empfehlen das SQLite Backend möglichst bald durch eine vollausgewachsene Datenbank zu ersetzen. Aus diesem Grund haben wir die Models dahingehend angepasst, dass Sie dem aktuellen Dantebankschema entsprechen. 
Der Django ORM kann daraus Datenbankspezifisches SQL DDL generieren, und so die Migration erheblich erleichtern.

\subsubsection{Split der Configfiles}
TODO Danilo

\subsubsection{Weitere Punkte}
\begin{description}
\item[Django Admin-Interface] Django bietet die Möglichkeit die Datenbank über
ein automatisch generiertes Admin-Interface zu verwalten. Auf diese Weise
können, potentiell fehleranfällige, Datenmanipulationen per SQL vermieden
werden. Die Models wurden mit den nötigen Metadaten erweitert, damit dieses
Feature aktiviert werden konnte.

\item[Erstellen von Files und Versions] Bisher war es nicht möglich über das
Oberfläche von strongTNC neue Files und neue Versionen zu erstellen. Die
Ansichten wurden um diese Funktionalität ergänzt.

\item[Verknüpfung von Daten in Views] Die Views wurden durch sinnvolle
Verknüpfungen ergänzt. Die  Verknüpfungen waren bereits in der Datenbank
vorhanden, jedoch in den Views nicht direkt ersichtlich, so zum Beispiel welche
Enforcements einer Gruppe zugeordnet sind.

\item[URL Hash Parameter] Um Parameter in der URL abzulegen und auszulesen,
wurde eine Javascript Hilfsbibliothek erstellt. Die Bibliothek erlaubt es, die
Parameter in der URL abzulegen ohne einen Reload auszulösen. Ausserdem kann auf
Änderungen Eventbasiert (Observer Pattern \cite{gof94}) reagiert werden.
Änderungen welche mittels Ajax ausgelöst und somit keinen Reload zur folge
haben, können so über die URL und die Browser History zugänglich gemacht werden.
\end{description}




