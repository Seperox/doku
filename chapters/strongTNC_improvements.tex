\section{Erweiterungen}

\subsection{Qualität}

\subsubsection{Aufteilung in Apps}

\subsubsection{Continous Integration}

\subsubsection{Testing und Code Standards (PEP8)}

\subsubsection{Konsequente verwendung von URL names}

\subsubsection{Konsequente Frontend Validierung}

\subsubsection{Konsistente Datums verwendung UTC}

\subsubsection{Depolyment Dokus, Vagrant, Ansible}

\subsection{Features}

\subsubsection{Aufteilung der Zugriffsrechte}
Um die Informationen in strongTNC zu Präsentationszwecken zugänglich zu machen,
ohne dass Änderungen vorgenommen werden können, weder absichtlich noch aus
Versehen, soll eine Readonly Rolle eingeführt werden.

In einem ersten Schritt soll ein Modell mit zwei Rollen eingeführt werden. Eine
Rolle für den readonly Zugriff und eine für den Vollzugriff. Die Rollen sollen,
so wie es gegenwärtig implementiert ist, nicht personalisiert sein. Die
Möglichkeit, den Login zu personalisieren sollte nicht grundsätzlich
ausgeschlossen werden, jedoch steht die Implementation eines nicht
personalisierten readonly Zugriffs im Vordergrund.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Das Django Webframework hat ein vollständiges Authentication- und
Permission-System integriert. Damit lassen sich komplexe Permission-Szenarien
abbilden, jedoch besteht auch die Möglichkeit nur Teile daraus zu verwenden und
so ein einfacheres Rollen-Modell zu simulieren.

Da keine personalisierten Logins benötigt sind, werden zwei technische Benutzer
erstellt, die für die beiden Rollen eingesetzt werden. Die Namen der beiden Benutzer sind 
 \texttt{admin-user} und \texttt{readonly-user}. Dem
\texttt{admin-user} Benutzer wird eine \texttt{write\_access} Berechtigung erteilt, diese
kann in den Views mittels Django-Internem \texttt{@permission\_required()}
Decorator geprüft werden.

Diese Variante der Umsetzung erlaubt es, mit wenig Aufwand personaliserte Logins
einzuführen. Für die Verwaltung der Benutzer stellt Django ein Admin-Interface
zur Verfügung, die Benutzerverwaltung muss nicht selber entwickelt werden.

In den Templates können die Zugriffsrechte über das \texttt{perms} Objekt im
\texttt{Context} geprüft werden:

\begin{pythoncode}
{% if 'auth.write_access' in perms %}
    <p>Read-write access.</p>
{% endif %}
\end{pythoncode}

Die zusätzliche Implementation eines Templatetags erleichtert die Steuerung von HTML Formularelementen deren Bedienung nur für schreibberechtigte Benutzer erlaubt sein soll:

\begin{pythoncode}
@register.simple_tag(takes_context=True)
def input_editability(context):
    perms = context.get('perms', [])
    if 'auth.write_access' not in perms:
        return 'disabled="disabled"'
    return ''
\end{pythoncode}

Die Anwendung sieht wie folgt aus:

\begin{pythoncode}
<input type="text"name="name" value="{{ group }}" {% input_editability %} />
\end{pythoncode}

Diese Umsetzung folgt einer Variation, dem in \cite{posa1} vorgeschlagenen Pattern \enquote{Full Access With Errors}. Alle Funktionen sind stets für den Benutzer sichtbar. Dadurch kann das User Interface einheitlich gestaltet werden und vermeidet auf diese Weise mögliche Verwirrungen. Diejenigen Elemente, die der Benutzer nicht bearbeiten darf, werden deaktiviert. 

Um die beiden benötigten Benutzer initial zu erstellen, wurde das Django
Management-Kommando \texttt{setpassword} angepasst. Das Kommando erstellt direkt
die beiden Benutzer und erlaubt es die Passwörter interaktiv oder per Parameter
festzulegen.

\paragraph{Alternativen} \hspace{0px} \\
Als Alternative zum Django Permission-System könnten auch die standardmässig
vorhandenen Flags \texttt{user.is\_admin} und \texttt{user.is\_staff} verwendet
werden. Dies wäre bedeutend einfacher zu implementieren, jedoch ist die Lösung
nicht ausbaufähig. Deshalb wird das Permission-System bevorzugt.

\subsubsection{Nachladen von grossen Datenmengen}
strongTNC muss grossen mit Datenmengen umgehen können. Wenn Datei-Messungen
durchgeführt- oder SWID Tags erfasst werden, ist beispielsweise die Zahl der
erfassten Dateien schnell im fünfstelligen Bereich. Wenn einzelne dieser Dateien
ausgewählt werden sollen, muss verhindert werden, dass immer die gesamte Menge
der Daten geladen wird.

\paragraph{Technische Umsetzung} \hspace{0pt} \\
Die gesuchten Datensätze werden mittels inkrementeller Suche per Ajax
nachgeladen.

Die Ajax Endpunkte werden mit Hilfe von
\enquote{Dajax-ice}\footnote{\url{http://www.dajaxproject.com/}} realisiert.
\enquote{Dajax-ice} übernimmt sämtliche Vorkehrungen die nötig sind um mit Django
einen Ajax Request zu behandeln. So werden zum Beispiel benötigte HTTP Header
automatisch gesetzt und geprüft. Ausserdem generiert \enquote{Dajax-ice} für
jeden Ajax Endpunkt eine Javascript Funktion, welche die benötige Infrastruktur bereitstellt um Ajax Requests auszuführen.
\\
Ein Ajax Endpunkt kann wie eine übliche Django View entwickelt werden.

\begin{listing}
\caption{Beispiel eines Ajax Endpunktes}
\begin{pythoncode}
@dajaxice_register
@ajax_login_required
def directories_autocomplete(request, search_term):
    dirs = Directory.objects.filter(path__icontains=search_term)
    results = {'results': [{'id': d.id, 'directory': d.path} for d in dirs]}
    return json.dumps(results)
\end{pythoncode}
\end{listing}

Der Javascript-Aufruf für diesen Endpunkt sieht wie folgt aus:

\begin{jscode}
Dajaxice.apps.filesystem.directories_autocomplete(callback, {search_term: 'system'});
\end{jscode} 

Damit bei der inkrementellen Suche nicht bei jedem Tastenanschlag ein Request
abgesetzt wird, wurde ein Wrapper implementiert, welcher erst einen Request
absetzt wenn für eine bestimmte Zeit keine Eingabe mehr gemacht wurde.

<TODO: Evtl. sequenz diagramm oder code? Erwähnen, dass das filtern der files schwierig ist?>

\paragraph{Langlaufende Operationen / Fehlerbehandlung}
Asynchrone Aufrufe bringen zwei wesentliche Probleme mit sich. Zum einen kann es sein, dass Fehler auftreten, wie z.B Timeouts, die der Benutzer nicht bemerkt. Um zum anderen, muss für den Benutzer ersichtlich sein, ob Datenübertragungen im Hintergrund anstehen und falls ja, wann diese erfolgreich abgeschlossen sind. Speziell für langlaufende Operationen durch Datenbankintensive Abfragen oder grosse Datenmengen können Antwortzeiten im Sekundenbereich entstehen. \\
Zu diesem Zweck wurde eine Proxy Komponente \cite{gamma1994design} implementiert, welche Anstelle des eigentlichen Dajax-ice Aufrufes eingesetzt wird. Komponenten, deren Inhalte per Ajax nachladen werden, werden vom Proxy mit einem Statusindikator besetzt. Zusätzlich wurde ein globaler Statusindikator eingeführt, der anzeigt, ob mindestens eine asynchrone Datenübertragung stattfindet.\\
Treten Fehler bei einer Ajax Datenübertragung auf, wird der Benutzer mittels Alert Box über den Fehler informiert.

\subsubsection{Ajax Pagination}
Um in grossen Datenmengen zu navigieren mit der Möglichkeit diese auch zu
filtern wurde die bestehende statische Pagination durch eine dyamische Ajax
basierte Version ausgetauscht. Diese hatte die Anforderung, dass es möglich sein
sollte jegliche Art von Daten seitenweise auszuliefern, sowie die Daten zuvor zu
Filtern. Um dies zu erreichen wurde eine generische Paginiation implementiert,
welche es erlaubt, die zu unterteilenden Daten mittels \enquote{Strategy
Pattern}\cite{gamma1994design} aufzubereiten.

Die Implementation der Paginierung besteht aus den folgenden vier Teilen:
\begin{enumerate}
	\item Javascript Frontend Komponente
	\item Template Tag, Templates und HTML Markup
	\item Generischer Ajax Endpunkt
	\item \enquote{List Producer} für die Datenaufbereitung
\end{enumerate}



\paragraph{Technische Umsetzung} \hspace{0pt} \\


\subsubsection{Erstellen von Files und Versions}

\subsubsection{Models für MySQL Support erstellt}
\paragraph{Empfehlung für Wechsel der Datenbank}
Durch die angesprochene enge Kopplung von strongSwan und strongTNC durch eine gemeinsame Datenbank, bedingen Anpassungen des Datenbankschemas Änderungen an allen Komponenten.
Desweiteren ist zu erwarten, dass für grössere Installationen SQLite zu leichtgewichtig wird.
Optimierungen und Profiling sind sehr eingeschränkt, zu dem wird keine referenzielle Integrität unterstützt.
\paragraph{Generierung des Datenbankschemas}
Django unterstütz diverse Datenbankbackends \footnote{\url{https://docs.djangoproject.com/en/dev/ref/databases/}}, so unter anderem MySQL, PostgreSQL, MSSQL und das zur Zeit verwendete SQLite.
Wir empfehlen das SQLite Backend möglichst bald durch eine vollausgewachsene Datenbank zu ersetzen. Aus diesem Grund haben wir die Models dahingehend angepasst, dass Sie dem aktuellen Dantebankschema entsprechen. 
Der Django ORM kann daraus Datenbankspezifisches SQL DDL generieren, und so die Migration erheblich erleichtern.

\subsubsection{Split der Configfiles}

\subsubsection{Django Admin-Interface}
